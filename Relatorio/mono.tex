\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[alf]{abntcite}
%\usepackage[alf,iso-690-1987}{abntcite}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage{amsmath}
\usepackage{enumitem}

\renewcommand{\ABNTbibliographyname}{Referências}


\makeatletter
\usepackage{babel}
\makeatother
\begin{document}

\autor{Bruno Pereira Pinho\\
       Danilo Luvizotto\\
       Pedro da Cunha Nariyoshi}


\titulo{HIPERION - Plataforma Versátil de Desenvolvimento Multi Rotor}

\comentario{Monografia  de conclusão de curso apresentado à Escola Politécnica da Universidade de São Paulo para obtenção do título de Engenheiro Eletricista \\
Área de concentração: Sistemas Eletrônicos\\
Orientador: Marcelo Knörich Zuffo\\
Co-orientador: Sérgio Takeo Kofuji}

\instituicao{Departamento de Sistemas Eletrônicos \par Escola Politécnica\par Universidade
de São Paulo}

\local{São Paulo}


\data{2011}

\capa

\folhaderosto
%Projeto do Trabalho de Formatura apresentado à Escola Politécnica da USP como parte dos requisitos da disciplina PSI2591-Projeto de Formatura I.
% \begin{folhadeaprovacao}
% Relatório Inicial sob o título \textit{``\ABNTtitulodata''}, apresentado à Escola Politécnica da USP como parte dos requisitos da disciplina PSI2592-Projeto de Formatura II, perante a banca examinadora constituída pelos
% professores: \setlength{\ABNTsignthickness}{0.4pt}
% 
% \assinatura{Prof. Marcelo Knörich Zuffo\\ Orientador} \assinatura{Prof. Sérgio Takeo Kofuji}
% \assinatura{Profa. Ramona M. Straube Shukovski}
% 
% \end{folhadeaprovacao}
\begin{resumo}
  Este projeto tem como objetivo propor e implementar uma plataforma de desenvolvimento voadora. O intuito é criar uma base de conhecimento para que projetos posteriores possam se beneficiar do conhecimento adquirido. O projeto será implementado em camadas hierárquicas, tal como o modelo OSI. Esta abstração torna o projeto mais versátil e expansível.
  
  Palavras chave: \textit{modular, vôo, brushless, multi-rotores, plataformas embarcadas, sistemas sem fio, telemetria, baterias Li-Poli, sistemas eletrônicos}
\end{resumo}

\begin{abstract}
  This project's objetive is to propose and implementa a flying development platform. Its goal is to generate a knowledge base in order that following projects may benefit from the acquired know-how. This project will be implemented using hierarchic layers, similar to the OSI model. This abstraction allows a more versatile and expandable project.
  
  Keywords: \textit{modular, flight, brushless, multirotors, embedded platforms, wireless systems, telemetry, li-poly batteries, electronic systems}
\end{abstract}


 \chapter*{Agradecimentos}
 Agradecemos primeiramente a Deus por estar presente em nossas vidas e nos abençoando, tornando assim todo o nosso sucesso possível.
 
 Agradecemos as nossas famílias, que dedicaram grande quantidade de recursos na nossa educação, muitas vezes de maneira sacrificial, e sempre com amor. E também  a nossas companheiras pela paciência e apoio que tiveram neste momento de muita tensão e trabalho.
 
 Agradecemos também ao corpo docente da Escola Politécnica, por nos ensinar, ocasionalmente contra nossa vontade, mas sempre para o nosso bem. Em especial a aqueles que ensinam com paixão. 
 
 No escopo deste projeto, ainda agradecemos os professores Marcelo Zuffo e Sergio Kofuji que acreditaram no projeto e aceitaram a tarefa de nos orientar.
 
 E não podemos esquecer os funcionários do LSI, especialmente ao Weslley Torres e os funcionários do Nate que nos providenciou ajuda e conselhos durante esses semestres.

\chapter*{Lista de Siglas e Abreviaturas}

\begin{description}[style=multiline,leftmargin=3cm]
  \item[API] \textit{(Application Programming Interface)}   Interface de Programação de Aplicativo, um conjunto de normas que permite uma interface entre dois aplicativos ou um aplicativo e um plugin.
  \item[ARM] \textit{(Advanced Risc Machine)}   é uma arquitetura de processadores de 32-bits RISC.
  \item[Brushless, Motor]    um motor que não utiliza uma escova para a comutação. Esses motores necessitam de um controlador eletrônico para gerar a comutação.
  \item[ESC] \textit{(Electronic Speed Controller)}   Controlador de Velocidade Eletrônico, é um dispositivo que faz a comutação das fases num motor sem escova.
  \item[GNU/Linux]   é um sistema operacional que utiliza as ferramentas do projeto GNU e o núcleo Linux.
  \item[GPS] \textit{(Global Positioning System)}    sistema utilizado para obter informações sobre tempo e posição de um objeto, utilizando 4 ou mais satélites.
  \textit{Inrunner}   um motor cujo estator se encontra no exterior, e o rotor do lado interior.
  \item[LSI]   Laboratório de Sistemas Integráveis, parte da Escola Politécnica da Universidade de São Paulo.
  \item[MVA]   Mícro-Veículo Aéreo, é uma classe de VANTs de tamanho reduzido.
  \item[Multirrotor]   um objeto voador dotado de duas ou mais hélices e que se utiliza do empuxo causado por essas para o vôo.
  \item[OSI, Modelo]   uma arquitetura que divide redes de computadores em diversas camadas, utilizada para modelar e abstrair as redes.
  \item[Outrunner]   um motor cujo estator se encontra no exterior, e o rotor no interior.
  \item[PID, Controlador]   um controlador que emprega um algoritmo proporcional, integrativo e diferencial ao erro para controle de processos.
  \item[RISC] \textit{(Reduced Instruction Set Computer)}    é uma estratégia para desenvolvimento de processadores que se restringe as instruções a um grupo reduzido de instruções simples.
  \item[RTOS] \textit{(Real-Time Operating System)}    Sistema operacional de Tempo-Real.
  \item[SDK] \textit{(Software Development Kit)}   Kit de Desenvolvimenteo de Software é um conjunto de aplicativos, documentação e exemplos para auxíliar e/ou permitir o desenvolvimento de softwares para determinada plataforma.
  \item[VANT]   Veículo Aéreo Não-Tripulado, controlado remotamente ou autônomamente.
\end{description}

\listoffigures

\listoftables

\tableofcontents{}

\part{Primeira parte - Relatório do projeto}
\chapter{Introdução\label{cap:introducao}}

\begin{flushright}{}``\emph{Sobre hipérion, nos é dito que foi o primeiro a entender,\\
                            através de atenção diligente e observação,\\
                            os movimentos da lua e de outros corpos celestes, (...)\\
                            foi ele também aquele que tornou esses fatos conhecidos;\\
                            e por esta razão ele foi chamado de pai desses corpos(...)}''\\
{\small Diodoro da Sicília (5.67.1)}\end{flushright}{\small \par}

\section{Contextualização e Motivação}
A evolução da tecnologia ao longo da história permitiu ao homem desenvolver as mais diversas ferramentas, desde as que o auxiliam no trabalho até os dispositivos dedicados ao lazer. A depender do tamanho desses objetos, seus transportes podem ser feitos de diversas maneiras; pequenos objetos podem ser carregados, mas, para objetos um pouco maiores, isso já pode não ser possível ou conveniente, de forma que pode ser necessário incorporar a eles partes dedicadas a facilitar a sua movimentação. 

Dentre as possíveis soluções para a movimentação de ferramentas de pequeno porte, uma solução recente é o uso de Micro-Veículos Aéreos (MVAs). Um MVA possui algumas vantagens em relação aos outros meios, dentre as quais pode-se destacar a versatilidade, já que o movimento não depende do terreno e, por isso, ele passa por cima de obstáculos que são de difícil transposição para pernas ou rodas. Além disso, os MVAs tem um grau de liberdade adicional, já que podem variar a sua altura, conseguindo chegar a posições impossíveis para veículos terrestres ou aquáticos.

Essa última característica torna o MVA ótimo para uma grande variedade de usos nos quais são desejadas agilidade e mobilidade. É o caso de câmeras de vídeo controladas à distância, que podem ser usadas, por exemplo, para a filmagem de eventos esportivos ou para a imersão em realidade aumentada. 

O desenvolvimento científico tem possibilitado sistemas embarcados cada vez mais potentes, e isto tem aumentado o interesse em MVAs, tanto para pesquisas, quanto para aplicações profissionais. No entanto, não há uma plataforma de desenvolvimento, apenas produtos comerciais com objetivos específicos. Dessa forma que é necessário primeiro o desenvolvimento de um sistema multirrotor para que então seja iniciada a pesquisa.

\section{Objetivos}

O projeto visa a implementação de um multirrotor modular expansível para uso  como uma plataforma de desenvolvimento para aplicações futuras e implementação de uma aplicação que demonstre o potencial do protótipo gerado. A ênfase do projeto é a arquitetura modular e discreta do multirrotor, que permitirá que aplicações e sensores sejam adicionados ou removidos com o mínimo de alterações tanto no software quanto no hardware desenvolvidos. Para que isso seja possível, serão definidos os requisitos dos módulos de aplicação, seus protocolos de comunicação e o barramento onde eles serão ligados, dentre outros, além das APIs a serem geradas. Será necessária, também, uma documentação apropriada que permita que o usuário compreenda e utilize todos os recursos sem dificuldades.

	O sistema será construído em camadas, semelhante ao modelo OSI de camadas. Um diagrama do sistema pode ser encontrado no anexo 1. O módulo de controle cuidará dos algoritmos de vôo como estabilidade, PID, ele recebe o sinal dos sensores mais essenciais ao vôo e recebe também comandos vindos do módulo de navegação.

	O módulo de navegação se encarrega de utilizar os sensores disponíveis para decidir qual rota tomar, ele recebe sinais do controle remoto, além de estar ligado aos sensores não essenciais através do barramento, esses sensores são utilizados para fazer correções na rota.
	
	É possível ainda expandir o projeto através de um módulo de aplicações. Este seria ligado ao barramento como um periférico comum, mas possuiria um processador mais poderoso e lidaria com sinais de som e vídeo. Ele também poderia ser responsável pelos cálculos mais custosos e por carregar o programa que o multirrotor executará no modo autônomo. Por estar ligado no barramento, ele também é capaz de se comunicar com os outros periféricos para processar estes dados também.

O protótipo final deverá possuir capacidades suficientes para o seu uso como uma plataforma de desenvolvimento. Essas capacidades incluem, mas não se limitam a:
\begin{itemize}
  \item Capacidade de vôo estável;
  \item movimentação em 3 eixos e rotação em torno do eixo vertical;
  \item aferição e envio de dados dos sensores.
\end{itemize}

A navegação poderá ser de duas formas. O modo manual, onde o multirrotor é controlado remotamente pelo usuário. E o modo semi-autônomo, que utiliza rotas pré-definidas, guiando-se pelo GPS, incluindo a funcionalidade de voltar ao ponto de origem caso seja perdida a conexão com o controle manual.


\section{Organização do Trabalho}

Este trabalho possui mais 8 capítulos, além dos anexos, referências e bibliografias. Nos capítulos 2  e 3 serão apresentados os principais elementos tecnológicos e  teóricos do projeto. O desenvolvimento do trabalho será apresentado no capítulo 4, no qual serão mostrados as competências e habilidades do grupo, metodologia e objetivos do projeto, descrição das atividades, dificuldades e limitações encontradas.
Nos capítulos 5, 6, 7 e 8 serão apresentados os tópicos relacionados ao orçamento do projeto, cronogramas, riscos e gerência de projeto.
Para finalizar, o capítulo 9 concluirá o trabalho, apresentado uma síntese de tudo que foi visto e, neste capítulo, também serão mostrados os resultados obtidos. Nas referências, bibliografias e nos anexos serão apresentados complementos e fontes de informações relevantes ao projeto.

\chapter{Arquitetura}
\begin{flushright}{}``\emph{Navegar é preciso, viver não é preciso.}''\\
{\small Luís de Camões}\end{flushright}{\small \par}

A arquitetura proposta foi pensada de forma a permitir ao multirrotor fácil adaptabilidade a projetos de pesquisa futuros e a outras finalidades não previstas ou não implementadas no protótipo inicial. O software e o hardware foram divididos em quatro camadas de abstração, cada qual com uma parcela bem definida das tarefas que, em conjunto, são responsáveis pelo funcionamento do sistema.

As camadas são:
\begin{enumerate}
  \item Camada de excitação dos motores, responsável por controlar a rotação dos rotores;
  \item Camada de estabilização do vôo, responsável por garantir a estabilidade do vôo;
  \item Camada de navegação, responsável pela velocidade e pela direção de deslocamento do sistema;
  \item Camada de periféricos, que comporta os sensores de navegação e o receptor de rádio-controle, e onde é possível acrescentar módulos personalizados.
\end{enumerate}

A figura \ref{fig.arquitsimp} apresenta uma visão geral da arquitetura, que será detalhada mais adiante:
\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/Arquitsimp.eps}
  \caption[Arquitetura simplificada]
  {visão geral da arquitetura do multirrotor}\label{fig.arquitsimp}
\end{figure}

\section{Camada de excitação dos motores}
\subsection{Descrição}

Essa é a primeira camada, abaixo da camada de estabilização de vôo. Responsável por garantir que a rotação dos motores esteja de acordo com o determinado, por detectar e proteger os motores de sobrecorrentes e por fornecer a potência que eles necessitam para funcionar. Deve impedir que os motores queimem caso os rotores fiquem presos ou girem em aberto.

\subsection{Componentes}

É constituída pelos $n$ motores, hélices e controladores eletrônicos de velocidade ({\it eletronic speed controllers} - ESCs), sendo $n$ o número de rotores do multirrotor. Os ESCs projetados, por sua vez, são constituídos por duas placas de circuito, uma responsável pela lógica e a outra pelo fornecimento de potência aos motores. ESCs comerciais costumam ter esses dois sub-circuitos na mesma placa.

\subsection{Comportamento}

O controlador eletrônico de velocidade (ESC) lê o parâmetro de rotação enviado pelo microcontrolador da camada de estabilização e aguarda um sinal do motor que indica que o enrolamento está alinhado com o campo do rotor. Quando isso ocorre, o ESC calcula o tempo ideal para o chavear a excitação do motor, espera esse tempo e realiza o chaveamento, depois do qual o ciclo recomeça.

Para maiores detalhes sobre funcionamento do ESC, ver a seção \ref{sec:esc}.

Abaixo, um diagrama que representa esse comportamento:

\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/Excit-func.eps}
  \caption[Funcionamento do ESC]
  {visão geral do funcionamento do ESC}\label{fig.escfunc}
\end{figure}

\subsection{Comunicação entre os componentes}

Cada ESC precisa comunicar-se com o microcontrolador ARM da camada de estabilização de vôo. O ESC projetado o faz através do protocolo I$^2$C, enquanto que a maior parte dos ESCs comerciais recebe um PWM como entrada, com a limitação de não poderem enviar o estado do motor. Devido ao alto custo de fabricação em baixa escala, foram usados ESCs comerciais no protótipo do multirrotor. Apenas um ESC projetado foi construído, como prova de conceito.
Os motores recebem três PWMs dos ESCs, que o alimentam.

\subsection{Parâmetros de entrada e saída}

\subsubsection{Entrada}
\begin{itemize}
      \item da camada de estabilização de vôo:
      \begin{itemize}
        \item rotação do motor (para cada ESC + rotor).
      \end{itemize}
\end{itemize}


\subsubsection{Saída}
\begin{itemize}
  \item para a camada de estabilização de vôo:
  \begin{itemize}
    \item estado de cada motor: funcinamento correto ou erro (apenas para o ESC projetado).
  \end{itemize}
\end{itemize}

\section{Camada de estabilização do vôo}
\subsection{Descrição}

Processa os sinais dos sensores de estabilização (acelerômetros e giroscópios) e os parâmetros de navegação (ângulos de Euler e potência total dos motores) e gera os parâmetros de rotação de cada motor. Responsável por manter a estabilidade do vôo e controlar as velocidades de deslocamento e angular do multirrotor.

\subsection{Componentes}

Camada constituída por um microcontrolador ARM (Cortex-M0 modelo LPC1114 da NXP, família ARMv6-M, arquitetura Cortex-M) e por uma unidade de medida inercial (IMU - \textit{inertial measurement unit}), que é uma placa de circuito que contém o acelerômetro e o giroscópio tridimensionais.

\subsection{Comportamento}

A camada de estabilização age através de um laço que inicia com a leitura dos parâmetros de navegação, oriundos daquela camada, e segue com a leitura dos sinais dos sensores de estabilização. O próximo passo é a execução dos algoritmos PID que geram os parâmetros de rotação dos motores, os quais são enviados aos ESCs da camada de excitação.

Os algoritmos que controlam a estabilidade são PIDs não-lineares, ver a seção \ref{sec:controle} para mais detalhes. A figura \ref{fig.estabfunc} representa esse comportamento.

\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/Estab-func.eps}
  \caption[Funcionamento da camada de estabilização]
  {visão geral do funcionamento da camada de estabilização}\label{fig.estabfunc}
\end{figure}

\subsection{Comunicação entre os componentes}

O microcontrolador dessa camada comunica-se com os ESCs da camada de excitação por I$^2$C, caso seja o ESC projetado, ou por PWM, caso seja um ESC comercial. A comunicação com a IMU dá-se por I$^2$C e com a camada de navegação por UART.

\subsection{Parâmetros de entrada e saída}

\subsubsection{Entrada}
\begin{itemize}
  \item da camada de navegação:
  \begin{itemize}
    \item ângulos de Euler e potência total dos motores (parâmetros de navegação).
  \end{itemize}
\end{itemize}


\subsubsection{Saídas}
\begin{itemize}
  \item para a camada de excitação dos motores:
  \begin{itemize}
    \item rotação de cada motor.
  \end{itemize}
  \item para a camada de navegação:
  \begin{itemize}
    \item estado de cada motor: funcinamento correto ou erro (apenas para o ESC projetado);
    \item dados dos sensores de estabilização (acelerômetro e giroscópio).
  \end{itemize}
\end{itemize}

\section{Camada de navegação}
\subsection{Descrição}

Responsável por processar os sinais dos sensores de navegação (GPS, magnetômetro e sensor de distância ultrassônico) e os parâmetros do rádio-controle. Gera os parâmetros de navegação (ângulos de Euler e potência total dos motores) do multirrotor, de forma a fazê-lo mover-se com a direção e a velocidade pretendidas e/ou girar em torno de seu eixo vertical.

\subsection{Componentes}

Camada constituída por uma placa Arduino Mega dotada de um microcontrolador da Atmel ATMega1280, família AVR8.

\subsection{Comportamento}

A camada de navegação possui um laço principal que tem início com a leitura dos parâmetros de direção e velocidades de translação e angular, os quais são obtidos do módulo de recepção do rádio-controle e/ou podem ser gerados por outros módulos na camada de periféricos. Isso abre a possibilidade de aplicações arbitrárias determinarem a direção e as velocidades do multirrotor.

Em seguida ocorre a leitura dos sinais dos sensores de navegação (GPS, magnetômetro e sensor de distância ultrassônico). O GPS fornece a informação de onde o multirrotor está e a sua altitude, o magnetômetro indica para que direção ele está voltado e o sensor ultrassônico, colocado apontando para baixo, também indica a altitude. A utilidade do sensor ultrassônico é que ele é mais preciso que o GPS e funciona em ambientes internos, diferentemente deste. Sua limitação é o alcance, limitado a três metros. A partir disso os dados do GPS são usados, se disponíveis.

A partir desses parâmetros e sinais é realizado o processamento que gera os parâmetros de navegação (ângulos de Euler e potência total dos motores) que são enviados para o microcontrolador da camada de estabilização. A figura \ref{fig.navfunc} representa esse comportamento.

\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/Navega-func.eps}
  \caption[Funcionamento da camada de navegação]
  {visão geral do funcionamento da camada de navegação}\label{fig.navfunc}
\end{figure}


\subsection{Comunicação entre os componentes}

O Arduino comunica-se por UART com o microcontrolador ARM da camada de estabilização. A comunicação com os sensores da camada de periférios também ocorre por UART, no caso dos módulos GPS e magnetômetro, e por GPIO, no caso do sensor ultrassônico.

\subsection{Parâmetros de entrada e saída}

\subsubsection{Entradas}
\begin{itemize}
  \item da camada de periféricos:
    \begin{itemize}
      \item sinais dos sensores de navegação (GPS, magnetômetro e sensor ultrassônico);
      \item parâmetros de direção e velocidades de translação e angular do multirrotor.
    \end{itemize}
  \item da camada de estabilização de vôo:
  \begin{itemize}
    \item estado de cada motor: funcinamento correto ou erro (apenas para o ESC projetado);
    \item dados dos sensores de estabilização (acelerômetro e giroscópio).
  \end{itemize}
\end{itemize}

\subsubsection{Saídas}
\begin{itemize}
  \item para a camada de estabilização de vôo:
  \begin{itemize}
    \item ângulos de Euler e potência total dos motores (parâmetros de navegação)
  \end{itemize}
  \item para a camada de periféricos:
  \begin{itemize}
    \item estado de cada motor: funcinamento correto ou erro (apenas para o ESC projetado);
    \item dados dos sensores de estabilização (acelerômetro e giroscópio), caso solicitado por algum módulo periférico.
  \end{itemize}
\end{itemize}

\section{Camada de periféricos}
\subsection{Descrição}

A camada de periféricos abriga originalmente os módulos dos sensores de navegação e o módulo receptor do rádio-controle. É possível adicionar a ela módulos com funcionalidades arbitrárias, que podem, inclusive, assumir a tarefa de gerar os parâmetros de direção e velocidades ao lado do receptor de rádio-controle, o que abre um leque de possibilidades de projetos futuros, dentre os quais citamos: controle de altura através de sensores como barômetro ou sensor de distância a laser, evasão de colisão, rastreamento e perseguição de objeto através de um módulo multimídia inteligente, além de transmissão de vídeo e áudio.


\subsection{Componentes}

Originalmente, os sensores de navegação (módulos GPS, magnetômetro e sensor ultrassônico) e o módulo receptor de rádio-controle. Módulos de expansão arbitrários podem ser adicionados nessa camada.

\subsection{Comportamento}

Os sensores da camada de periféricos apenas esperam o pedido de leitura do microcontrolador da camada de navegação e/ou de algum outro módulo da própria camada. Quando isso acontece, eles provêem seus dados mais recentes.

Módulos personalizados desta camada possuem comportamento que varia de acordo com suas funcionalidades. Mais detalhes devem ser obtidos da documentação dos próprios módulos.

\subsection{Comunicação entre os componentes}

Os módulos GPS e magnetômetro e o receptor de rádio-controle comunicam-se com o Arduino da camada de navegação por UART. O sensor ultrassônico usa comunicação GPIO.

\subsection{Parâmetros de entrada e saída}

\subsubsection{Entrada}
\begin{itemize}
  \item   do rádio-controle remoto:
  \begin{itemize}
    \item sinal do rádio-controle.
  \end{itemize}
\end{itemize}
\subsubsection{Saídas}
\begin{itemize}
  \item   para a camada de navegação:
  \begin{itemize}
    \item sinais dos sensores de navegação (GPS, magnetômetro e sensor ultrassônico);
    \item parâmetros de direção e velocidades do multirrotor.
  \end{itemize}
  \item   para o rádio-controle remoto:
  \begin{itemize}
    \item estado de cada motor: funcinamento correto ou erro (apenas para o ESC projetado);
    \item dados dos sensores de estabilização (acelerômetro e giroscópio);
    \item dados dos sensores de navegação (GPS, magnetômetro e sensor ultrassônico);
    \item parâmetros de direção e velocidades do multirrotor, caso gerados por algum módulo embarcado.
  \end{itemize}
\end{itemize}

\chapter{Referencial Teórico\label{cap:referencialteorico}}

\begin{flushright}{}``\emph{A mente que se abre a uma nova idéia \\
jamais voltará ao seu tamanho original.}''\\
{\small Albert Einstein}\end{flushright}{\small \par}

\section{Considerações Iniciais}

Neste capítulo serão apresentados os conceitos e a terminologia básicos da área do projeto e a bibliografia do trabalho. O conteúdo deste relatório é suficiente para o entendimento do funcionamento deste projeto. Para uma visão mais detalhada sobre os diferentes temas abordados neste capítulo, recomenda-se a leitura da bibliografia citada.

\section{Motores \textit{Brushless}\label{sec:brushless}}

A escolha dos motores é essencial para o projeto, pois fornecem a propulsão necessária para o vôo. Há diversos tipos de motores disponíveis no mercado, síncronos ou assíncronos, de corrente contínua ou alternada etc.

Como o veículo armazena sua energia em uma bateria, foram escolhidos motores de  de corrente contínua, já que isto elimina a necessidade de inversores complexos, permitindo o uso de circuitos chaveadores mais simples.

A maioria dos motores de corrente contínua utilizam um dispositivo denominado escova para chavear seus enrolamentos. Este é composto por fios dispostos de forma fazer contato com os enrolamentos do rotor, enquanto este gira. Apesar de ser uma solução efetiva para diversas aplicações, a escova impõe diversas limitações como:

\begin{itemize}
  \item faiscamento;
  \item ruído acústico;
  \item ruído elétrico;
  \item desgaste mecânico devido ao atrito;
  \item menor eficiência;
  \item menor relação potência $\times$ tamanho;
  \item maior velocidade angular.
\end{itemize}

Há motores de corrente contínua que não utilizam escovar para fazer o chaveamento, estes são denominados \textit{brushless} (``sem escova'' em inglês). Estes motores são semelhantes em construção síncronos trifásicos com imãs permanentes, mas otimizados para operação em corrente contínua.

Por não possuir a escova para fazer o chaveamento entre os enrolamentos, é necessário um circuito eletrônico que execute a mesma função. Apesar de aumentar a complexidade do sistema, multirrotores necessitam de motores com rotações elevadas, o que impossibilita o uso da escova. Além disto, como os multirrotores são alimentados por uma bateria, é interessante que o sistema seja o mais eficiente o possível, para aumentar o tempo de vôo.

Estes motores geralmente possuem 3 enrolamentos que controlam o campo no estator, enquanto o rotor utiliza imãs permanentes. Isto elimina a necessidade da escova para gerar o campo no rotor.

Hoje em dia, eles são utilizados em uma grande variedade de aplicações. Desde pequenos motores encontrados em ventoinhas de computador, a motores maiores encontrados em veículos, como o Segway \cite{segway}.

Para mais informações, consultar \cite{avr443}.

\section{Controlador de Velocidade Eletrônico\label{sec:esc}}

O controlador de velocidade, também chamado de \textit{ESC} é um circuito eletrônico utilizado para substituir os comutadores mecânicos. Seu papel é chavear os enrolamentos de forma síncrona com o motor até que este atinja a velocidade desejada.

\subsection{Sincronização \textit{sensorless}}
Como é necessário que o controlador saiba a posição do rotor para pode chaveá-lo, é necessário que haja algum tipo de realimentação entre o motor e o ESC. Alguns motores empregam sensores de posição Hall ou codificadores rotatórios como forma de realimentação. No entanto isto aumenta ainda mais o custo e a complexidade do sistema. Há uma maneira de se obter a informação sobre a posição do motor sem a necessidade de sensores externos que utiliza as tensões no próprio enrolamento para definir as posições.

Controladores que utilizam esta técnica são chamados de \textit{sensorless} (do inglês sem sensor), apesar do nome, é de fato um sistema dotado elementos sensores. O funcionamento deles é análogo ao funcionamento de um gerador síncrono. Ao passar pelos enrolamentos, o campo magnético do rotor induz tensões nos enrolamentos. A tensão induzida é proporcional à frequência angular e sua fase indica a posição do rotor. Durante o chaveamento, apenas 2 enrolamentos estão conectados (um ao $V_{SS}$ e outro ao $V_{DD}$, enquanto um deles está ``flutuando'', a tensão neste enrolamento é utilizada para indicar a fase do rotor. 

Diferentemente das máquinas síncronas comuns, os motores brushless são projetados para que a tensão induzida tenha formato trapezoidal, isto facilita a detecção da posição do rotor. Quando o motor atinge $(V_{DD}+V_{SS})/2$ sabe-se que o campo magnético do rotor está alinhado com o campo magnético do enrolamento sendo analisado. Este evento é denominado cruzamento de zero (CZ), pois caso a fonte seja simétrica $V_{DD}=-V_{SS}$. Após o cruzamento deste ponto, o ESC inicia um \textit{timer} que, quando expira, chaveia o circuito.

A figura \ref{fig.escchav} demonstra o funcionamento do método:

\begin{figure}[h!]
  \centering
  \includegraphics[width=4in]{./Figuras/ESC-chaveamento.eps}
  \caption
  {Funcionamento do método \textit{sensorless}.}\label{fig.escchav}
\end{figure}

\subsection{Máquina de estados}

Para descrever o funcionamento do programa (baseado em \cite{avr444}) pode-se utilizar a máquina de estados representada na figura \ref{fig.escdia}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/ESC-diagrama.eps}
  \caption
  {Máquina de estados do laço principal do programa do ESC}\label{fig.escdia}
\end{figure}

Na inicialização dos periféricos, inicia-se os conversores A/D, a comunicação I$^2$C, os \textit{timers}, as portas e comparadores.

A partida do motor é constituída pelo carregamento da sequência de chaveamento, do chaveamento em malha aberta e da inicialização do \textit{timer Watchdog}. Este \textit{timer} é utilizado para detectar travamentos no motor. Se nenhuma comutação é executada dentro de um intervalo pré-determinado, o controlador entende que o motor está parado e tenta dar a partida novamente.

As tarefas não relacionadas às interrupções envolvem principalmente a comunicação e outras funções que se podem ser adicionadas ao código.

As tarefas de chaveamento serão tratadas por interrupções, para que o chaveamento ocorra sinconizadamente com a movimentação do rotor. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=3in]{./Figuras/ESC-interrupt.eps}
  \caption
  {Fluxograma de interrupções}\label{fig.escint}
\end{figure}

Durante a comutação, o sinal lido pelo conversor A/D é muito ruidoso, o que aumenta substancialmente a chance de alarme de CZ falso. Adiciona-se um \textit{timer de Hold-Off} para que a leitura do conversor A/D só ocorra após o ruído de comutação desvanecer. Após a interrupção de \textit{Hold-Off}, a leitura do conversor A/D é ativada.

As leituras de corrente e da tensão contra-eletromotriz são feitas quando há transbordo no timer do PWM, também para evitar interferência nas medidas. 

Além destas medidas, é aplicado um filtro IIR passa-baixas digital na medida da tensão contra-eletromotriz, para evitar o chaveamento espúrio. O filtro possui esta forma:

\begin{equation}
  y_n = \frac{ax_n + by_{n-1}}{a+b}.
\end{equation}

Este filtro possui resposta em frequência:

\begin{equation}
H(e^{j\omega}) = \frac{a}{a+b(1-e^{-j\omega})}.
\end{equation}

Pode-se notar que ele possui ganho $\approx 1$ para baixas frequências e o ganho cai para $\frac{a}{a+2b}$ para altas frequências.

Para reduzir a complexidade da divisão e melhorar a estabilidade, $a+b$ devem ser uma potência de $2$, para que a divisão possa ser convertida em um deslocamento de bits. O manual \cite{avr444} sugere o uso de $a=1$ e $b=3$.

\subsection{Partida}

Como os imãs geram uma tensão alternada de amplitude proporcional à velocidade angular entre o rotor e o estator, não é possível utilizar esta técnica durante a partida ou em baixas rotações. Isto é especialmente crítico para sistemas em que a carga é variável ou imprevisível. Quando a carga é conhecida ou está numa faixa previsível, o problema se torna mais tratável, mas mesmo assim não há uma técnica universal para a partida do motor \cite{avr444}.

Este mesmo manual sugere a partida em malha aberta, que é o mais utilizado para este tipo de aplicação. Para isto, o controlador espera um período pré-determinado antes de chavear o circuito. Após obter velocidade angular suficiente o controlar habilita a realimentação.

A carga deve estar numa faixa conhecida. Se a carga estiver muito abaixo do esperado, o motor poderá não chavear rápido o suficiente, colocando o enrolamento em curto e possivelmente danificando o motor. Se a carga estiver muito acima do esperado, o motor não se moverá e a partida do motor irá falhar.

\subsection{Condicionamento dos sinais}

  Os sinais de realimentação contém ruído, principalmente devido ao chaveamento dos transistores. Além disso, o nível do sinal pode não estar na faixa correta. Para que os sinais representem corretamente as informações de interesse, se utiliza de circuitos condicionadores de sinal.
  
  Nesta aplicação, a maior parte deles é composta por um circuito divisor de tensão passa-baixas. Este circuito é bastante simples, podendo ser montado com apenas 3 componentes passivos:
  
  \begin{figure}[h!]
  \centering
  \includegraphics[width=1in]{./Figuras/ESC-sigcond.eps}
  \caption
  {Condicionador de sinais}\label{fig.escsigcond}
\end{figure}

  Regulando os resistores e o capacitor pode-se escolher a faixa de tensão e resposta em frequência do circuito. Não é desejável que o filtro seja de banda estreia, pois ele se torna ``lento'' e deforma o sinal de interesse.
  
  Foram pesquisados diferentes combinações e decidiu-se por resistores de $4,7k\Omega$ e um capacitor de $100nF$. Estes valores proprocionam ganho de $0,5$ para baixas frequências e frequência de corte próxima a 2kHz, que equivale a 120000RPM, o que é uma ordem de grandeza maior que as rotações que espera-se do motor.

\section{Bateria de lítio-polímero}

A bateria é o elemento que provê a energia necessária ao funcionamento eletromecânico e eletrônico do multirrotor. É desejável que sua massa seja baixa, já que um peso maior significará mais empuxo nos motores e uma maior corrente drenada. Ao mesmo tempo, é desejável uma carga elétrica alta, para se ter mais autonomia.

O lítio é o mais leve dentre os metais e com o maior potencial eletroquímico, o que o torna uma escolha bastante atraente para o uso em baterias. Devido à sua grande reatividade, porém, seu uso na forma metálica não é conveniente, sendo mais usados os compostos que provêem íons de lítio sem sofrer grandes modificações estruturais \cite{lipoeval,batterysearch}. 

A bateria de lítio-polímero é ideal para uso em veículos elétricos por conseguir armazenar uma grande quantidade de energia por unidade de massa (energia específica) e por unidade de volume (densidade de energia), além de fornecer uma grande quantidade de potência por unidade de volume (densidade de potência), por ter alta eficiência energética, alta capacidade de corrente e vida útil longa \cite{lipoeval}.

Essas características justificam seu uso mesmo apesar das dificuldades que ela introduz, já que as células são extremamente inflamáveis, tensões maiores que 4,5V causam a dissociação do eletrólito - danificando a célula e podendo causar explosão - e tensões abaixo de 1V causam dissociação do eletrodo negativo \cite{enlipomodel}.

\subsection{Química}

A bateria de lítio-polímero normalmente usa um óxido de lítio com outro metal como eletrodo positivo e um composto de carbono como eletrodo negativo \cite{advlipo}. As reações químicas envolvidas no funcionamento da bateria são \cite{lipostatusquo,lipoeval}:

Eletrodo positivo:
\begin{equation}
  LiMO_2 \Longleftrightarrow Li_{(1-x)}MO_2 + x Li^+
\end{equation}

Eletrodo negativo:
\begin{equation}
C_n + xLi + xe^- \Longleftrightarrow C_nLi_x
\end{equation}

Reação completa:
\begin{equation}
LiMO_2 + C_n  \Longleftrightarrow Li_{(1-x)}MO_2 + C_nLi_x
\end{equation}

Em geral, o metal $``M''$ associado ao lítio no óxido do eletrodo positivo é o cobalto \cite{lipostatusquo,lipoeval}.

\subsection{Modelo}

Em \cite{enlipomodel} foi desenvolvido um modelo para as baterias de lítio-polímero considerando o efeito da variação da temperatura nas características elétricas. O esquema pode ser visto abaixo:

\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/modelo.eps}
  \caption[Modelo da Bateria]
  {Esquema elétrico do modelo desenvolvildo em \cite{enlipomodel}}\label{fig.bateria}
\end{figure}

No lado esquerdo do diagrama, o capacitor, o resistor e a fonte de corrente controlada por corrente modelam a capacidade, a auto-descarga e o estado de carga (SOC) da bateria. A capacidade da bateria é uma função do número de ciclos de carga e descarga, mas esse efeito é desprezível para baterias de lítio-polímero. No lado direito do esquema, a fonte de tensão controlada por tensão é usada para simular a relação não linear entre o estado de carga e a tensão de circuito aberto (OCV). Rseries modela a resistência ômica interna da célula, e as redes RC consideram o comportamento transitório. Cada parâmetro usado para modelar $V_cell$ é função do estado de carga e da temperatura. A tensão medida nos contatos da célula podem ser expressadas no domínio $s$ como \citeonline{enlipomodel} sugere:

\begin{equation}
  V_{cell} = V_{OC}(SOC,T) - I_{cell}R_{series}(SOC,T)  - I_{cell}Z_{t_long}(SOC,T) - I_{cell}Z_{t_short}(SOC,T)
\end{equation}

onde $Zt\_long$ e $Zt\_short$ são as impedâncias dos dois grupos RC. As duas constantes de tempo $\tau t\_long$ e $\tau t\_short$ estão na magnitude dos segundos e dos minutos respectivamente \cite{enlipomodel}. 

O método para obtenção dos parâmetros acima citados está descrito em \citeonline{enlipomodel}.

\subsection{Valores de referência}

Seguem alguns valores de referência, extraídos de \citeonline{lipoeval}, onde é estudada uma bateria de lítio-polímero de 3,7V e 100Ah:
\begin{itemize}
  \item Energia específica : 146 Wh/kg
  \item Densidade de energia: 373 Wh/l
  \item Auto-descarga: < 5\% por mês
  \item Eficiência energética > 95\% entre 20 e 40 ºC
  \item Temperatura de operação: entre -20 e 60 ºC
  \item Vida útil (perda de 20\% da capacidade original): 1200 ciclos de carga / descarga
\end{itemize}

\section{Sensores}

Existem hoje uma grande quantidade de sensores eletrônicos que são usados em diversas aplicações embarcadas. Com eles, torna-se possível diversas aplicações embarcadas. Com eles, torna-se possível observar diversos parâmetros do mundo exterior e poder atuar conforme estes parâmetros.

Com base na existência destes sensores se tornou possível aplicações como este projeto. Segue-se então uma pequena descrição dos sensores que foram utilizados.

\subsection{Sensores inerciais}

Sensores inerciais são utilizados para medir o deslocamento do multi-rotor. Para este projeto foram utilizados acelerômetros e giroscópios MEMS. Estes dispositivos possuem baixo consumo e boa precisao.

O conjunto escolhido foi a unidade de medida inercial de 6 graus de liberdade da SparkFun \ref{sparkfun}. Este kit é composto por um acelerometro ADXL345 e um giroscopio ITG3200. Ambos chips são capazes de se comunicar por I$^2$C, o que torna a leitura imune ao ruído de leitura A/D do microcontrolador e ainda diminui a quantidade de fios necessária para a comunicacao. A saída digital ainda oferece a vantagem de dispensar a calibração de offset. 

\subsubsection{Acelerômetro}

Acelerômetro é um sensor capaz de medir aceleração própria de um objeto. A aceleração própria é a somatória das forças de campo que agem no acelerômetro, estas são geralmente equivalentes à resultante subtraida das forças normais).

No multirrotor deseja-se obter o ângulo de inclinação do veículo, e não as acelerações. Para obter os dados desejados deve-se utilizar uma transformação sobre os valores para poder-se estimar os ângulos.

Quando em movimento uniforme, a única aceleração sofrida pelo veículo é a aceleração da gravidade. Portanto a aceleração vista pelo sensor dependerá apenas da aceleração da gravidade e dos ângulos de Euler. Para pequenas variações de ângulo, as equações são:

\begin{subequations}
\begin{align}
  A_x = g \sin(\theta),
  A_y = g \sin(\phi),
  A_z = g \sqrt{1 - \sin^2(\theta) - \sin^2(\phi)}.
\end{align}
\end{subequations}

Linearizando, obtém-se:

\begin{subequations}
\begin{align}
  A_x = g \theta,
  A_y = g \phi,
  A_z = g.
\end{align}
\end{subequations}

No entanto, devido às outras acelerações e vibrações sofridas pelo veículo, esta medida é bastante ruidosa. O tratamento deste ruído é descrito na secao \ref{fusao}.

\subsubsection{Giroscópio}

Os giroscópios são sensores inerciais que medem a velocidade angular. Como os angulos sao as integrais das velocidades, estes sensores também podem ser utilizados para estimar os ângulos de Euler.

Um inconveniente de utilizar este sensor para estimar os angulos é que não há referencial inercial, portanto só é possível estimar as diferenças ao longo tenpo, mas não o estado inicial. Alem disto pequenos erros de medida se aculam ao longo do tempo e não é possível corrigí-los apenas utilizando este sensor. 

Para medir a velocidade angular, o sensor funciona corretamente. Possuir a velocidade angular é interessante, porque torna desnecessário inferir este valor a partir do acelerômetro. A diferenciação feita desta maneira reduz o ruído e permite o uso de valores derivativos mais altos.

\subsubsection{Fusão de dados inerciais}\label{fusao}

Há diversas maneiras de fundir os dados dos sensores de maneira a conseguir leituras mais precisas \ref{balancefilter}. Como a plataforma é embarcada, não 

\subsection{GPS}

O sistema de posicionamento global, mais conhecido como GPS é um sistema de navegação utilizando satélites. Este sistema utiliza 4 satélites e fazendo uma triangulação do sinal ele é capaz de dizer a exata latitude e longitude de um ponto.

Ele é capaz de fazer esta medição utilizando a diferença de tempo que os sinais destes quatros satélites calculando assim as três cordenadas, latitude, longitude e altitude; e também calcula o tempo.

Com este sensor, é possível que o multirrotor se localize e possa se mover entre dois pontos de maneira autônoma.

\subsection{Magnetômetro}

O magnetômetro é um sensor capaz de medir campos magnéticos. Como a Terra produz um campo magnético, este campo pode ser medido de modo que este sensor seja utilizado conforme uma bússula.

Com o auxilio do magnetômetro é possível encontrar os polos terrestres e também encontrar a direção e o sentido que o multirrotor está virado sem que ele se mova.

Devido a estas qualidades este sensor é fundamental para auxiliar o multirrotor a se mover de maneira autônoma, pois sem ele só é possível saber em que direção ele está olhando caso ele esteja em movimento e o dado anterior e o atual do GPS seja comparado.

\subsection{Sensor de distância}

Sensores de distância podem ser utilizados para diversas funções em veículos voadores, como evitar colisões, medir distâncias ou velocidades. Para cada tipo de aplicação, deve-se considerar o ângulo de visada (que é a abertura onde o sensor consegue detectar obstáculos), distância máxima detectável, preço e precisão. 

\subsubsection{Sensores de Infravermelhos}

Sensores infravermelhos são sensores de baixo custo que detectam a reflexão de raios infravermelhos. 

Esses sensores são compostos por um emissor LED que emite ondas infravermelhas e um detector (fotorresistor ou fototransistor). O LED e o sensor são dispostos de forma que a luz emitida pelo LED seja refletida por objetos que se aproximam e seja detectada pelo sensor. 

Esses sensores são de baixo custo e podem se utilizados também para transmissão de dados (como em controles remotos convencionais) e desacoplamento de chaves (relés ópticos). 

Nos conjuntos LED/Sensor pesquisados, a distância máxima está na ordem de milímetros a centímetros. A reflexão depende bastante das caracteristicas do material, como rugosidade e material. Isto torna o sensor impreciso e incapaz de detectar objetos escuros e opacos. Apesar de versáteis e baratos, estes não apresentam as características desejadas para este projeto.

\subsubsection{Sensores superssônicos}

Ondas acústicas superssônicas apresentam qualidades interessantes. Seu comprimento de onda é da ordem de milímetros, portanto é possível produzir transdutores bastante direcionais em dimensões diminutas (lobo principal de poucos graus em um transdutor de menos de 1 centímetro de raio). Ao mesmo tempo, também é grande o suficiente para apresentar resposta indiferente à rugosidade da maioria dos materiais. 

Como a distancia e medida pelo tempo (ao invés da intensidade como no sensor infravermelho), atenuação tambem não apresenta problemas a detecção e precisão. 

O módulo utilizado, modelo $HC-SR04$ produzido por diversos fabricantes, contém ainda a lógica para a geração e detecção dos sinais. Basta que o microcontrolador envie o sinal de acionamento (trigger) e meça o tempo até o pino eco (echo) ficar ativo. Isto permite que o modulo central execute outras funções e confere maior confiabilidade aos dados, já que ele trabalha em tempo real.

O $HC-SR04$ apresenta alcance de ate $4,5$ metros e abertura de $15^o$, o que é suficiente para controle de altura e prevenção de colisões. Neste projeto foi utilizado para controle de altura, mas o código desenvolvido pode ser facilmente adaptado para outras funcoes. 

\section{Controle}\label{sec:controle}

O tema sobre controle de multirrotores voltou a ser estudado, graças a tecnologias novas e o grande interesse em \textit{VANTs}. Há diversas pesquisas já publicadas e os métodos desenvolvidos obtém resultados satisfatório, apesar de não haver o estabelecimento de uma teoria clássica especificamente para multirrotores. 

\subsection{Características}

O controle de um veículo multirrotor apresenta diversas diferenças em relação a sistemas lineares invariantes no tempo, que são estudados mais a fundo no curso. Primeiramente, se trata de um sistema de múltiplas entradas e múltiplas saídas, sendo que todas as entradas influenciam todas as saídas. Além disto, é um sistema não-linear e dinâmico.

Observa-se que os motores apresentam relação não-linear entre a potência consumida e o empuxo gerado. \citeonline{nlflight} expressam o torque e empuxo gerados por:

\begin{subequations}
\begin{align}
  T & = C_T \rho A r^2 \Omega^2, \\
  Q & = C_Q \rho A r^3 \Omega^2
\end{align}
\end{subequations}
onde $A$ é a área da hélice, $r$ o raio da hélice, $\rho$ a densidade do ar, $\Omega$ a rotação do motor e $C_T$ e $C_Q$ são constantes aerodinâmicas. Como algumas dessas variáveis são constantes, pode-se simplificar a fórmula para:

\begin{subequations}
\begin{align}
  T & = C'_T \Omega^2, \\
  Q & = C'_Q  \Omega^2
\end{align}
\end{subequations}

Apesar de não explicitado no artigo, essas relações são válidas apartir de rotações elevadas, onde a impedância da hélice se torna semelhante à impedância do ar. Semelhante ao comportamento de alto-falantes e em baixas frequências, em baixas rotações não há acoplamento entre a hélice e o ar.

Considerando a faixa nominal de uso das hélices, tratam-se de curvas monotônicas, cuja derivada apresenta pequenas variações nas proximidades de qualquer ponto. Isto permite que se utilize de aproximações lineares. Foi estudada a possibilidade do uso de aproximações afins ou tabelar os valores, todavia essas opções se mostraram muito mais computacionalmente custosas e não oferecem desempenho muito superior. Como conhecemos a região de uso do motor, foi utilizada uma solução linear de mínimos quadrados, considerando uma distribuição uniforme ao longo dos ciclos de trabalho enviáveis ao motor. 

O sistema também apresenta características dinâmicas e não-lineares (semelhante a um pêndulo). Dependendo dos ângulos de Euler, as forças e torques geradas pelos motores serão diferentes. Apesar das magnitudes iguais, terão direções diferentes e, portanto, suas componentes serão diferentes. Ao mesmo tempo, a componente da gravidade se mantém na mesma direção 

Os sensores também apresentam um problema para esta aplicação. Os acelerômetros medem a aceleração que o veiculo sofre e não os ângulos. Os giroscópios medem apenas a velocidade de variação dos ângulos. Se o veículo estiver em movimento inercial, e possível inferir os ângulos a partir da aceleração da gravidade, situação que não existe na prática. Também não é possível apenas integrar as leituras do giroscópio, pois haverá um erro na leitura que se acumula com o tempo. Pode-se utilizar outros sensores para se obter leituras mais confiáveis, como \ref{visionuav} que propõe um método de controle linear baseado em imagens de duas câmeras, uma no quadrrotor e outro no solo.

Por último, o sistema apresenta diversas entradas (para cada motor) e diversas saídas (três ângulos de Euler e aceleração nesta direção). Foram conferidos alguns artigos no assunto e como que alguns produtos comerciais controlam seus motores.

\citeonline{modellingpid} apresenta um modelo para um quadrirotor e é desenvolvido um método de controle proporcional-integral-derivativo (PID) clássico, com quatro forças de entrada que são os empuxos gerados pelos quatro rotores. Em \cite{nlpid} é projetado um controlador não linear baseado no esquema clássico de controle PID para controlar um quadrirotor. A posição horizontal do quadrirotor é controlada por ações PI, enquanto a orientação e a posição vertical são controladas por algorítmos PID. A performance é verificada por testes numéricos, embora apenas os efeitos da força gravitacional sejam compensados.

\citeonline{fuzzycontrol} formula um sistema de controle inteligente de quadrrotores baseado na lógica fuzzy. As entradas para o sistemas são o valores desejados para altura e os ângulos em relação aos três eixos de referência que passam pelo centro de massa, e as saídas são as potências de cada um dos quatro rotores para se atender à especificação. Por fim, são feitas simulações para validar a eficiência da estratégia de controle.

\subsection{Ortognalização}

Para sanar o problema pelas múltiplas entradas e saídas. Foi utilizada uma técnica para poder controlá-los independentemente. Para isso foi necessária uma troca de base.

A figura \ref{fig.topo} mostra a visão superior do multi-rotor. Os motores são denominados $1$, $2$, $3$ e $4$, sendo que o Motor $1$ é o motor no 1$^o$ quadrante.

\begin{figure}[h!]
  \centering
  \includegraphics[width=3in]{./FigsControle/Topo.eps}
  \caption[Vista superior do veículo]%
  {Vista superior do veículo}\label{fig.topo}
\end{figure}

Observando-se o veículo apartir da vista lateral (figura \ref{fig.lateral}) é fácil de observar como as forças atuam sobre o ângulo do multi-rotor.

\begin{figure}[h!]
  \centering
  \includegraphics[width=3in]{./FigsControle/Hover.eps}
  \caption[Vista lateral do veículo]%
  {Vista lateral do veículo}\label{fig.lateral}
\end{figure}

Considerando o ângulo entre o vetor normal à base e a aceleração da gravidade como $\theta$ e o rotor simétrico e com o centro de massa no centro geométrico. Pode-se escrever a equação que descreve o comportamento desse sistema como:

\begin{equation}
  \ddot{\theta} = - \frac{1}{J_\theta} (F_{M_1} + F_{M_2} - F_{M_3} - F_{M_4})d,
\end{equation}
onde:
\begin{description}[style=multiline,leftmargin=3cm]
  \item[J$_\theta$] é o momento angular do veículo em relação ao eixo;
  \item[F$_{M_n}$] é a força gerada pelo motor $n$;
  \item[d] é a projeção da distância entre o motor e o eixo $\theta$
\end{description}

Semelhantemente, pode-se escrever a equação para o outro ângulo ($\phi$) em relação à aceleração da gravidade:

\begin{equation}
  \ddot{\phi} = - \frac{1}{J_\phi} (F_{M_1} - F_{M_2} - F_{M_3} + F_{M_4}) d.
\end{equation}

Em relação à rotação em torno do eixo normal à base, pode-se gerar um torque resultante desbalanceando-se a rotação entre os motores que giram no sentido horário e os que giram no sentido anti-horário:

\begin{equation}
  \ddot{\psi} = - \frac{1}{J_\psi} (|T_{M_1}| - |T_{M_2}| + |T_{M_3}| - |T_{M_4}|),
\end{equation}
onde $T_{M_n}$ é o torque gerado pelo motor $n$.

Por último, a resultante do empuxo gerado pelos motores na direção normal à base é :

\begin{equation}
  F = F_{M_1} + F_{M_2} + F_{M_3} + F_{M_4}.
\end{equation}

Para controlar os ângulos e aceleração vertical independentemente foram criados quatro variáveis intermediárias, que atuam apenas em uma das equações (ortogonalização). As variáveis criadas são denominadas A, B, C e D.

\begin{equation}
  	\begin{bmatrix}
  	  A\\B\\C\\D
  	\end{bmatrix}
  	= 
  	\begin{bmatrix}
  	  -1 & -1 & +1 & +1\\
  	  -1 & +1 & +1 & -1\\
  	  -1 & +1 & -1 & +1\\
      +1 & +1 & +1 & +1
  	\end{bmatrix}
  	\begin{bmatrix}
  	  F_{M_1}\\F_{M_2}\\F_{M_3}\\F_{M_4}
  	\end{bmatrix}
  	.
\end{equation}

Utilizando essa nova base, pode-se controlar os parâmetros de forma independente:

\begin{subequations}
  \begin{align}
    \ddot{\theta} & = \frac{d}{J_\theta} A\\
      \ddot{\phi} & = \frac{d}{J_\phi} B\\
      \ddot{\psi} & = \frac{C_Q'}{C_T' J_\psi} C \\
      F & = D.
  \end{align}
\end{subequations}

O problema das múltiplas variáveis se extingue dessa maneira. O controle PID pode então ser aplicado às variáveis A, B, C e D e então estas são decompostas nas forças dos motores individuais. Esta abordagem permite ainda que sejam utilizados métodos diferentes para controlar cada variável.

\chapter{Desenvolvimento do Trabalho}

\begin{flushright}{}``\emph{É fazendo que se aprende a fazer aquilo \\
que se deve aprender a fazer.}''\\
{\small Aristóteles}\end{flushright}{\small \par}

\section{Considerações Iniciais}

Este capítulo trata de assuntos não relacionados às técnicas apresentadas no capítulo anterior. Serão discutidos aspectos sobre a equipe e como será executado o projeto. 

\section{Sobre a equipe}

O grupo é composto por três alunos: Bruno Pinho, Danilo Luvizotto e Pedro Nariyoshi. 

Bruno foi o responsável pela camada de navegação e de seus periféricos, como o gps, magnetometro e sensor de distancia. Responsável também da geração das curvas relacionadas ao trabalho. Também auxiliou nas demais partes do projeto.

Danilo foi o responsável por implementar a camada de controle. Responsável também pela estrutura do multirrotor, e auxiliando no desenvolvimento da arquitetura e nas demais partes do projeto.

Pedro foi o responsável por coordenar o projeto. Sendo responsável também pelo desenvolvimento da parte teórica do projeto. Trabalhou também na estrutura do multirrotor e participou ativamente de todas as atividades do projeto.

Na etapa de planejamento, a equipe contava com mais um integrante, Marcos Tortólio, que não está mais participando devido a um programa de intercâmbio na Espanha, como previsto.
Suas atividades no projeto foram relacionadas à pesquisa sobre a arquitetura de hardware e software do veículo. 

\section{Problema a ser resolvido}

	Apesar da existência produtos no mercado que utilizam sistemas multirrotores, não há nenhuma plataforma de desenvolvimento para aplicações diversas. Para fins de aprendizado e pesquisa, é comum que se desenvolvam sistemas de maneira independente e os utilizem para apenas um propósito. Nosso projeto busca criar uma plataforma de desenvolvimento versátil, disponibilizando abertamente o software, o hardware, os conhecimentos e a documentação gerados, de forma a criar uma base de conhecimento para o desenvolvimento do projeto e para seu uso como ferramenta.

	A Escola Politécnica da Universidade de São Paulo possui diversos laboratórios que poderiam utilizar o dispositivo para pesquisa, como reconstrução 3D de objetos, algoritmos de controle, aprendizado de máquina etc. O foco não é pesquisar nenhuma dessas áreas a fundo, mas sim criar uma ferramenta capaz de ser utilizada facilmente nessas aplicações.

	Pode-se comparar esse projeto a um SDK ou a uma API, ele permite ao desenvolvedor trabalhar sobre uma camada de abstração. Um desenvolvedor poderia por exemplo implementar técnicas de detecção de imagens para fazer busca de objetos sem a necessidade de compreender os motores trifásicos. Ao mesmo passo, um outro desenvolvedor poderia trabalhar no algoritmo de controle, sem se preocupar com os outros módulos do sistema.
	
\section{Motivações e Justificativas Técnicas}

	Um multirrotor com um número par de rotores tem vantagens substanciais sobre helicópteros convencionais. Se cada par adjacente de hélices girar em sentido oposto, é possível controlar o momento angular controlando a razão entre a rotação das hélices. Assim, um multirrotor é capaz de reduzir o problema eletromecânico de voar a um problema de controle eletrônico.

	O projeto implementa conhecimentos diversos da Engenharia Elétrica, como controle, programação, processamento de sinais, redes de computadores, circuitos elétricos, e é, portanto, é adequado e representativo à meta generalista do curso.

	Além de colocar em prática conceitos aprendidos durante o curso, também nos aprofundaremos nas áreas de controle multivariável, processamento de imagens e sistemas eletrônicos embarcados.

	Por fim, a plataforma desenvolvida poderá ser utilizada por projetos posteriores, já que a área de veículos aéreos não-tripulados (VANTs) possui diversas vertentes de pesquisa em andamento.

\section{Descrição das Atividades Realizadas}
As etapas do projeto foram: Estudo Preliminar, Definições, Construção da Plataforma de Desenvolvimento, Estudo de Algoritmos de Controle, Construção do Protótipo, Controle Avançado, Desenvolvimento das Aplicações e Montagem Final. A seguir estão descritas as atividades e suas respectivas subatividades.

\begin{enumerate}

  \item Estudo Preliminar \\
	Nesta etapa, os objetivos foram:
\begin{itemize}
  \item pesquisar sobre a construção de MVAs;
  \item pesquisar sobre as possíveis plataformas de desenvolvimento.
\end{itemize}

  \item Definições\\
	Nesta etapa, os objetivos foram:
\begin{itemize}
  \item definir os módulos básicos do veículo;
  \item definir uma arquitetura de hardware e software para implementar os controles e aplicações do veículo;
  \item definir alguns componentes básicos, tais como: tipos de motor e drivers;
  \item definir o número de hélices.
\end{itemize}

  \item Estudo de um multirrotor comercial\\
	Nesta etapa, os objetivos foram:
  \begin{itemize}
    \item escolha de um modelo comparando com outros existentes no mercado;
    \item compra e estudo teórico do multirrotor escolhido;
    \item montagem e estudo da parte estrutural;
    \item avaliação dos pontos fortes e fracos;
    \item utilizar a experiência e o conhecimento adquirido para auxiliar na construção do protótipo.
  \end{itemize}
  
  \item Construção da Plataforma de Desenvolvimento\\
	Nesta etapa, os objetivos foram:
\begin{itemize}
  \item comprar componentes;
  \item construção do hardware básico;
  \item desenvolver bibliotecas básicas de interface do microcontrolador;
  \item estudar o comportamento dos motores.
\end{itemize}

  \item Estudo de Algoritmos de Controle\\
	Nesta etapa, os objetivos foram:
\begin{itemize}
  \item estudar a construção de um multirrotor comercial;
  \item pesquisar possíveis algoritmos de controle.
\end{itemize}

  \item Controle Avançado\\
	Nesta etapa, os objetivos foram:
\begin{itemize}
  \item implementar sistema básico anticolisão(apenas relacionado a altura);
  \item implementar o módulo e sistema de navegação manual;
  \item implementar o módulo e sistema de navegação autônoma ;
\end{itemize}

  \item Desenvolvimento das Aplicações\\
Nesta etapa, os objetivos foram:
\begin{itemize}
  \item construção do módulo GPS;
  \item implementar sistema de navegação por GPS;
\end{itemize}

  \item Construção do Protótipo\\
	Nesta etapa, os objetivos foram:
\begin{itemize}
  \item construir os módulos sensores básicos;
  \item construir o módulo central;
  \item conectar os módulos ao barramento da plataforma de desenvolvimento;
  \item ligar motores, módulo central e módulos sensores;
  \item testar sensores, comandos de voo e estabilidade.
\end{itemize}

  \item Montagem Final\\
	Nesta etapa, os objetivos foram:
\begin{itemize}
  \item Interligar todos os módulos;
  \item testar todos os sistemas e aplicações.
\end{itemize}

\end{enumerate}

\section{Metas}

O projeto resultou em quatro produtos, descritos abaixo:

\begin{enumerate}

  \item Curvas que relacionem as seguintes variáveis de interesse do multirrotor:
  \begin{itemize}
    \item força dos motores;
    \item autonomia;
    \item tipo de hélice.
  \end{itemize}
  
  \item Softwares dos micro-controladores que realizem, controlem ou possibilitem as seguintes tarefas:
  \begin{itemize}
    \item excitação dos motores;
    \item controle de vôo e estabilização;
    \item navegação manual ou por GPS;
    \item comunicação entre os módulos;
    \item comunicação sem fio.
  \end{itemize}
  
  \item Protótipo funcional de multirrotor que com as seguintes capacidades:
  \begin{itemize}
    \item receber dados de um controlador manual;
    \item voar pelo menos 10 minutos;
    \item levantar uma carga útil de pelo menos 1kg;
    \item realizar um percurso arbitrário em um raio de até 20m ao ar livre;
    \item percorrer uma rota através do módulo GPS entre dois pontos distantes de até 20m;
    \item possuir expansibilidade para módulos extras.
  \end{itemize}
  
  \item{Manual de projeto e construção de multirrotores, contendo:}
  \begin{itemize}
    \item guia para a construção de um multirrotor;
    \item explicação sobre o uso das curvas geradas;
    \item descrição da arquitetura;
    \item detalhamento do hardware suficiente para o uso e modificação por um iniciante;
    \item documentação do software e dos dados trocados entre as camadas;
    \item explicação sucinta das teorias por trás dos algoritmos.
  \end{itemize}
  
\end{enumerate}



\section{Dificuldades e Limitações}

Um problema encontrado foi a falta de documentação. Esta dificuldade se dá por dois motivos majoritários. O uso de motores \textit{brushless} e controladores é algo razoavelmente recente e pois o \textit{design} dispositivos se dá geralmente de maneira industrial ou amadora, portanto não há literatura bem estabelecida sobre o assunto.

A capacidade de escrita e comunicação também é um fator limitante. O estudante politécnico geralmente não utiliza essas habilidades e elas atrofiam com o tempo. Muitas vezes é difícil e demorado para transmitir uma ideia ou organizar os pensamentos da equipe.

A falta de um maior contato com micro-controladores também foi observada durante a execução da disciplina. Porém esta falta de contato foi concertada através de um estudo e uma pesquisa sobre o assunto.

No entanto, a disciplina foi capaz de expor estas deficências da equipe e exercitar as habilidades de comunicação dos membros.

\chapter{Cronograma}

\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/crono1.eps}
  \caption[Carta de Gantt do 1o. Semestre]%
  {Carta de Gantt do 1o. Semestre}\label{fig.crono1}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[width=6in]{./Figuras/crono2.eps}
  \caption[Carta de Gantt do 2o. Semestre]%
  {Carta de Gantt do 2o. Semestre}\label{fig.crono2}
\end{figure}

\chapter{Orçamento}

\begin{flushright}{}``\emph{Quando o dinheiro vai na frente,\\
todos os caminhos se abrem.}''\\
{\small William Shakespeare}\end{flushright}{\small \par}

\section{Considerações Iniciais}
Neste capítulo, foi feito um orçamento para fazer um estudo da viabilidade financeira do projeto e também para auxiliar na reprodução deste multirrotor dando idéia do preço dos componentes utilizados. Não foi considerado o frete nem o custo de impostos para importação.

\section{Valores}
\begin{tabular}{lr}
Sensores e GPS: &\$199,85 \\
~~ 1x IMU Digital Combo Board - ITG3200/ADXL345: & \$64.95 \\
~~ 1x LS20031 GPS Receiver: & \$59.95 \\
~~ 1x MicroMag 3-Axis Magnetometer: & \$49.95 \\
~~ 1x Ultrasonic Sensor - HCRS04: & \$25.00 \\
\\
ESC: & \$52.00 \\
~~ 4x ESCs &\$52.00\\
\\
Módulo de controle: &\$29.95 \\
~~ 1x LPC1114 LPCXpresso board &\$29.95\\
\\
Módulo de navegação: &\$28.99 \\
~~ 1x Arduino Mega board &\$28.99\\
\\
Baterias: & \$26,51 \\
~~ 2x ZIPPY Flightmax 5700mAh 2S3P 25C & \$26.51\\
\\
Motores: & \$65.52 \\
~~ 6x Motores Turnigy 450 H2218 Brushless outrunner 3550KV & \$65.52\\
\\
Estrutura: & \$45.00\\
~~ 2x Jogos com 6 hélices (3 de cada tipo) & \$7.00\\
~~ 2x Barra de fibra 3mm & \$3.00  \\
~~ 1x Placa de fibra 1mm & \$10.00\\
~~ 4x Barra de fibra 6mm & \$11.00\\
~~ 4x Adaptadores para hélices & \$8.00\\
~~ 4x Proteção para motores & \$6.00\\
\\
Protótipo para estudo: & \$1785.00 \\
~~ 1x MK Hexa2 Base Kit & \$1785.00\\

Total: & \$2232.82 \\
\\
Total - Protótipo: & \$447.82
\end{tabular}

\section{Conclusão}
Os valores apresentados neste capítulo servem para mostrar que o multirrotor proposto no projeto é viável financeiramente visto que os modelos comerciais possuem valores maiores que os cotados para construir este protótipo. 
Também é necessário relembrar que os valores mostrados não estão inclusos frete e importação e podem variar. Alguns componentes também podem ser trocados de modo que o protótipo pode ficar com um valor menor que o atual.


\chapter{Conclusões e trabalhos futuros\label{cap:conclusao}}

\begin{flushright}{}``\emph{Nada se cria, nada se perde, tudo se
transforma.}''\\
{\small Lavousier}\end{flushright}{\small \par}

Plataformas de desenvolvimento de veículos voadores autônomos são interessantes por permitirem a implementação de algoritmos e aplicativos de forma simples e rápida. Consegue-se isto isolando a aplicação dos outros módulos envolvidos no desenvolvimento de um multirrotor.
    
\section{Dificuldades encontradas}

O projeto envolve aspectos que nunca foram discutidos em sala de aula e que equipe não possui familiaridade, como controle de vôo. Estas etapas criam incerteza e é impossível afirmar o tempo que será gasto para o desenvolvimento desses módulos. Para minimizar esse problema, o projeto foi separado em blocos independentes e cada bloco será um \textit{milestone}.

Um problema encontrado foi a falta de documentação. Esta dificuldade se dá por dois motivos majoritários. O uso de motores \textit{brushless} e controladores é algo razoavelmente recente

Existe também os riscos associados a realização do projeto. Para montagem do hardware é necessário a importação de grande parte de componentes, como sensores e motores. A importação acarreta em outros riscos, como o atraso ou eventual extravio de encomendas. Este problema ocorreu na execução do trabalho. Os motores foram pedidos com um bom tempo de antecedência porém não chegaram. Para resolver este problema, outros motores tiveram que ser utilizados.

\section{Considerações sobre o Curso de Graduação}

A ênfase de Sistemas Eletrônicos tem por objetivo ser uma ênfase generalista, oferecendo tanto uma base sólida de conhecimentos fundamentais quanto um leque de opções para a especialização em uma área específica da Engenharia Elétrica. Neste projeto utiliza-se conceitos de dessas áreas aprendidos em diversas disciplinas.

Para a levitação e movimentação do multirrotor, utiliza-se conhecimentos aprendidos nas matérias do núcleo de controle, PTC2412 (Controle I) e PTC2512 (Laboratório de Controle). Além destas, a disciplina PSI2662 (Sensores e Atuadores) complementa este conjunto com metodologia de implementação de projetos embarcados e sensores para evitar colisões, e a disciplina PSI2661 (Transceptores) viabiliza a transmissão dos dados por radiofrequência.

A implementação do módulo de controle envolve as matérias de circuitos integrados PSI2451, PSI2452 e PSI2553 e de programação MAC2166 (Introdução à programação), MAC0122 (Algoritmos) e PCS2478 (Tópicos em Programação). Além disto, a construção dos circuitos de interface entre o controle e os motores e entre o controle e os sensores, utiliza-se conceitos aprendidos nos módulos de eletrônica, como PSI2223 (Introdução à eletrônica), PSI2324 (Eletrônica I) e PSI2326 (Eletrônica II).

	 Esta seção procura sumarizar e evidenciar as mais importantes, no entanto reconhece-se que há disciplinas que apesar de não mencionadas compõem os conhecimentos que serão utilizados neste projeto.

\section{Legado e aprendizado}
Para a realização deste projeto, muito conhecimento teve de ser empregado. Foi necessário uma grande interdiciplinaridade. Com isto, foi possível exercitar uma grande parte do conhecimento adquirido no curso.
Juntamente com o conhecimento teórico que foi ensinado nas aulas, também foi adquirido uma boa prática de engenharia. Como trabalhar em equipe, a formulação de relatórios, a formulação e execução de um cronograma. As dificuldades de projeto também foram um grande desafio que fizeram com que o grupo crescesse e descobrisse o que é a engenharia de verdade.
O resultado final do projeto é um legado a ser deixado para o departamento de sistemas eletrônicos. Como não existia nenhum projeto do gênero, a documentação gerada e o projeto em si pode e deve ser utilizado futuramente por outros grupos. Visando esta utilização foi criado uma vasta documentação teórica e também prática para a reprodução do projeto. Assim como também todas as dificuldades encontradas são listadas para que no futuro estas mesmas possam ser evitadas.

\bibliography{mono}


\chapter{Apêndice A - Comparativos entre outros multirrotores}

Existem diversas plataformas de multirrotores no mercado. A maioria composta por quadrirrotores. Entre estes, são notáveis: Aeroquad \cite{aeroquad}, Ardrone\cite{ardrone}, Microdrones\cite{microdrone}, Mikrokopter\cite{mikrokopter}.

O AeroQuad é um projeto de software e hardware livre dedicado à construção de helicópteros de quatro rotores de controle remoto. O hardware do AeroQuad consiste tipicamente em um microcontrolador Arduino (Mega-2560 ou Uno) que funciona como o controlador de vôo, juntamente com vários  sensores, como acelerômetros e giroscópios. O software, é escrito principalmente em C e enviado ao micro-controlador Arduino através do IDE, atualmente suporta o modo "Acrobatic", que usa apenas o giroscópio para auxiliar o vôo, e um modo "Estável" que usa tanto o giroscópio e acelerômetro para ajudar no vôo. 

ARDrone pertence à empresa Norte-Americana Parrot que atua na área de desenvolvimento de dispositivos sem fios para celular. O ARDrone é um quadcóptero comercial que se difere dos outros pelo fato que seu controle remoto é um celular ou Ipod.

Microdrones é uma empresa alemã cujo foco é o desenvolvimento de pequenas aeronaves, principalmente quadrirrotores. Possui hoje dois modelos comerciais à venda.

	Mikrokopter, é uma \textit{empresa} alemã dedicada a projetos de multirrotores, dentre as empresas pesquisadas, esta apresenta a maior quantidade de combinações. Há modelos com quatro, seis e oito hélices. Há documentação de muitos componentes, inclusive uma descrição detalhada sobre o tempo de vôo para diferentes configurações. Para mais informações, conferir \cite{mikrokopter}.

\chapter{Apêndice B - Curvas de relação}

\section{Considerações Iniciais}

Este capítulo mostrará as curvas geradas para a obtenção de parâmetros do motor e também a interpretação das curvas de interesse.

\section{Curvas a serem geradas}

Para gerar os parâmetros e auxiliar na construção do protótipo foram obtidas tabelas e curvas com os seguintes parâmetros:
  \begin{itemize}
    \item dois modelos de hélices diferentes;
    \item força resultante;
    \item corrente de alimentação do motor;
    \item rotação da hélice;
    \item tensão de alimentação do motor;
    \item sinal do controle;
   \end{itemize}

\section{Metodologia}
 
  Para tentar padronizar as medidas de modo que os resultados possam ser melhores comparados, foi-se atribuida a seguinte metodologia.

  Foi utilizada uma balança que foi acoplada a um suporte para os motores de modo que seja possível medir a força de cada motor. Para evitar certas interferências, o aparato tenta distanciar o máximo possível o motor da balança.

  Para gerar as curvas, foram feitas sete medidas, cada uma com um sinal do controle diferente, com as seguintes medidas: 16, 33, 50, 66, 84 e 100\%. Com isto a força que cada motor pode executar foi medida. Juntamente com a medida da força, a corrente e a tensão também foram obtidas para calcular a potência que o motor absorve e também a rotação para comparar com a força gerada.

  Foram utilizadas 2 tipos de hélices para tentar fazer uma melhor comparação de como estas podem alterar os demais parâmetros do projeto. Também foi alterado a tensão utilizando a hélice padrão para obter um melhor entendimento do funcionamento dos motores.

\section{Resultados}

 A primeira tabela gerada foi a dos parâmetros relacionados aos motores de acordo com o modelo de hélices. Para isto foi utilizado uma tensão fixa de 15V e apenas o sinal do controle foi variado.

\begin{table}[h!]

  \centering

  \begin{tabular}{|c|ccc|ccc|}

  \hline

  & Hélice & 10 / 4.5 & (Padrão) & Hélice & 9 / 3.8 & \\

  \hline

  Sinal & Força(mN) & i(A) & Rotação(rpm) & Força(mN) & i(A) & Rotação(rpm) \\

  \hline
  \hline

  16 \% & 68 & 0.5 & 2100 & 56 & 0.4 & 2880 \\
  33 \% & 163 & 1.2 & 3300 & 140 & 1.0 & 4260 \\
  50 \% & 295 & 2.5 & 4350 & 222 & 1.9 & 5310 \\
  66 \% & 454 & 4.5 & 5360 & 320 & 2.9 & 6240 \\
  84 \% & 650 & 7.6 & 6330 & 460 & 4.8 & 7410 \\
  100 \% & 810 & 10.9 & 7020 & 624 & 7.2 & 8340 \\
  \hline
  \end{tabular}
  \caption{Parâmetros relacionados aos motores de acordo com o modelo de hélices - Tensão 15V}
  \label{tabmotor}
\end{table}

A seguir a tensão foi diminuida pela metade para observar o comportamento dos demais parâmetros. 

\begin{table}[h!]
\centering
\begin{tabular}{|c|cc|}
\hline

Sinal & Força(mN) & i(A) \\

\hline
\hline

16 \% & 20 & 0.2 \\
33 \% & 51 & 0.5 \\
50 \% & 94 & 1.1 \\
66 \% & 153 & 1.8 \\
84 \% & 220 & 2.9 \\
100 \% & 292 & 4.3 \\
\hline
\end{tabular}
\caption{Parâmetros do motor com hélice padrão e tensão de variável}
\label{tabmotor2}
\end{table}

Para observar melhor a influência da tensão sobre os parâmetros, foi gerada a tabela abaixo, mantendo o sinal do controle constante e variando apenas a tensão.

\begin{table}[h!]
\centering
\begin{tabular}{|ccc|}
\hline

Tensão(V) & Força(mN) & i(A) \\

\hline
\hline

7.5  & 94 & 1.1 \\
10.0  & 144 & 1.4 \\
12.5  & 204 & 1.8 \\
15.0  & 295 & 2.5 \\
\hline
\end{tabular}
\caption{Parâmetros do motor com hélice padrão e tensão de 7.5V}
\label{tabmotortensao}
\end{table}

A partir das três tabelas criadas foram obtidas todas as seguintes curvas:

\begin{figure}[h!]
  \centering
  \includegraphics[angle=0]{./Figuras/forcaxhelice.eps}
  \caption[Curva: Força x Sinal]
  {Curva: Força x Sinal}\label{curvas.forcaxhelice}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[angle=0]{./Figuras/rotacaoxhelice.eps}
  \caption[Curva: Rotação x Sinal]
  {Curva: Rotação x Sinal}\label{curvas.rotacaoxhelice}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[angle=0]{./Figuras/correntexhelice.eps}
  \caption[Curva: Corrente x Sinal]
  {Curva: Corrente x Sinal}\label{curvas.correntexhelice}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[angle=0]{./Figuras/tensaoxcorrente.eps}
  \caption[Curva: Corrente x Tensão]
  {Curva: Corrente x Tensão}\label{curvas.tensaoxcorrente}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[angle=0]{./Figuras/tensaoxforca.eps}
  \caption[Curva: Força x Tensão]
  {Curva: Força x Tensão}\label{curvas.tensaoxforca}
\end{figure}


\section{Conclusão}

 As curvas que foram geradas mostraram o comportamento básico do motor facilitando melhor seu entendimento. Com isto foi possível escolher motores e hélices que melhor atendessem os objetivos propostos. Outra vantagem das curvas geradas foi poder escolher melhor o ponto de operação do multirrotor.

A tabela \ref{tabmotor} foi a responsável por gerar as curvas \ref{curvas.forcaxhelice}, \ref{curvas.rotacaoxhelice} e \ref{curvas.correntexhelice}, de modo que as conclusões possam ser mais fáceis percebidas. Com base nesta foi possível comparar dois modelos de hélices diferentes e também seus principais parâmetros como a rotação, a tensão, a força e a corrente. 

O primeiro tipo de hélice, a padrão, é maior que a segunda usado para a comparação. Observando a curva \ref{curvas.rotacaoxhelice}, observamos que a rotação aumenta conforme a hélice diminui. A rotação também parece ser linear com o sinal enviado para a ativação do motor.

Segundo as curvas \ref{curvas.forcaxhelice} e \ref{curvas.correntexhelice} percebe-se que a força e a corrente gerada pelo motor com uma hélice menor é também menor, diferentemente da rotação. Também é possível observar que a variação da força e da corrente não é linear com o sinal enviado. Conforme o sinal enviado se aproxima do máximo do motor a corrente e a força tendem a aumentar mais.

Com base na tabela \ref{tabmotor2}, pode-se fazer uma comparação do motor funcionando com uma tensão 50\% menor que a tensão da tabela \ref{tabmotor}. Podemos perceber que assim como a tensão diminuiu pela metade a corrente também caiu por praticamente a metade, reduzindo assim a potência pelo mesmo valor.
O valor da força que o motor gera cai também para um valor próximo da metade, mostrando que a força varia proporcionalmente com a potência do motor.
 
A partir dos gráficos \ref{curvas.rotacaoxhelice} e \ref{curvas.tensaoxcorrente} e também da tabela \ref{curvas.tensaoxforca} pode ser observado a influência da variação da tensão na força e na corrente do motor. Tanto a força quanto a corrente são praticamente lineares com a variação da tensão.

Outro fator importante que pode ser observado é que a corrente aumenta mais com a variação do sinal que a força gerada. Com base nesta informação, podemos admitir que o ponto ótimo para o funcionamento do motor é na faixa de 30\% a 60\%. Levando em conta que a corrente vai aumentar mais e a duração da bateria vai cair proporcionalmente, enquanto que a força gerada será um pouco menor se considerarmos a proporção.


 \part{Segunda Parte - Manual de Construção de um Multirrotor}
 %\setcounter{chapter}{0}
 \chapter{Considerações Iniciais}
 Este manual foi criado com o objetivo que qualquer pessoa com um mínimo de conhecimento técnico na área de microeletrônica seja capaz de construir seu próprio quadcóptero.

Caso seja do desejo do leitor se aprofundar mais sobre a teoria por trás do desenvolvimento deste projeto, é fortemente recomendado que a monografia relacionada a este projeto também seja lida. Porém é perfeitamente possível a construção de um protótipo sem o conhecimento teórico.

Aqui será citado as peças necessárias, o hardware e software utilizados bem como um guia para a montagem do protótipo.

 \chapter{Peças}
Aqui todas as peças utilizadas no projeto, desde a parte estrutural quanto a parte funcional, serão mostradas de maneira que seja possível a reprodução da parte estrutural e as compras da parte funcional.

 \section{Estruturais} 
 \begin{figure}[h!]
   \centering
   \includegraphics{./Figuras/cad_suporte_motor.eps}
   \caption[Placa de suporte do motor]
   {Placa de suporte do motor}\label{fig.protsupmotor}
 \end{figure}

 \begin{figure}[h!]
   \centering
   \includegraphics{./Figuras/cad_central_superior.eps}
   \caption[Placa central superior do protótipo]
   {Placa central superior do protótipo}\label{fig.protcentsup}
 \end{figure}

 \begin{figure}[h!]
   \centering
   \includegraphics{./Figuras/cad_central_inferior.eps}
   \caption[Placa central inferior do protótipo]
   {Placa central inferior do protótipo}\label{fig.protcentinf}
 \end{figure}

 \section{Funcionais} 
Todas as peças funcionais necessárias para a montagem do Hiperion está descrita neste capítulo, desde o hardware até os motores. A descrição de como fazer a ligação entre os componentes não será discutida aqui e sim na parte dedicada a montagem do protótipo. Assim também como o software utilizado será explicitado no seu devido capítulo.

Dentre o material que foi comprado encontra-se: 

\begin{itemize}
  \item IMU Digital Combo Board - ITG3200/ADXL345 - 1un;
  \item LS20031 GPS Receiver - 1un;
  \item ultrasonic Sensor - HCRS04 - 1un;
  \item LPC1114 LPCXpresso board - 1un;
  \item arduino Mega board - 1un;
  \item bateria - 1un; 
  \item motor - 4un; 
  \item ESC - 4un. 
\end{itemize}

A bateria, os motores e os ESCs podem variar de acordo com o gosto do usuário, podendo assim ter controle a respeito da carga, da autonomia e outros parâmetros. No protótipo original do Hipérion foi utilizado os seguintes itens:

\begin{itemize}
  \item Lipo 3399/4S battery - 1un;
  \item roxxy 2827-35 - black brushless motors - 4un;
  \item ESC da hobby king 20A - 4un. 
\end{itemize}

 \chapter{Softwares}

Neste capítulo serão listados todos os softwares utilizados e também aonde e como serão programados. Estes arquivos também se encontram no site: https://sites.google.com/site/hiperioncopter/ 

  \section{Estabilização}

Pequeno texto de como compilar os arquivos e aonde programar, etc...

\subsection{Config}

Escrever pequeno texto a respeito do que é o configurações

Seguem abaixo os arquivos utilizados:

\subsubsection{driver\_config.h}

\begin{verbatim}
/*
 * driver_config.h
 *
 *  Created on: 25/10/2011
 *      Author: Danilo Luvizotto
 */

#ifndef DRIVER_CONFIG_H_
#define DRIVER_CONFIG_H_

//#ifdef __USE_CMSIS
#include "LPC11xx.h"
//#endif

#define CONFIG_ENABLE_DRIVER_TIMER16                    1
#define CONFIG_TIMER16_DEFAULT_TIMER16_1_IRQHANDLER     0

#define CONFIG_ENABLE_DRIVER_TIMER32                    1

#define CONFIG_ENABLE_DRIVER_I2C						1
#define CONFIG_I2C_DEFAULT_I2C_IRQHANDLER				1

#define CONFIG_ENABLE_DRIVER_UART						1
#define CONFIG_UART_DEFAULT_UART_IRQHANDLER				1
#define CONFIG_UART_ENABLE_INTERRUPT					1

#define CONFIG_ENABLE_DRIVER_GPIO                       1

 /* DRIVER_CONFIG_H_ */
#endif\end{verbatim}

\subsubsection{target\_config.h}

\begin{verbatim}
/****************************************************************************
 *   $Id:: target_config.h 4832 2010-09-07 23:04:21Z nxp21346                 $
 *   Project: LED flashing / ISP test program
 *
 *   Description:
 *     This file contains the config settings for the blinky code sample
 *     which flashes an LED on the LPCXpresso board and also increments an
 *     LED display on the Embedded Artists base board. This project
 *     implements CRP and is useful for testing bootloaders.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/

#define LED_PORT 0		// Port for led
#define LED_BIT 7		// Bit on port for led
#define LED_ON 1		// Level to set port to turn on led
#define LED_OFF 0		// Level to set port to turn off led
#define LED_TOGGLE_TICKS 200 // 100 ticks = 1 Hz flash rate
#define FAST_LED_TOGGLE_TICKS 50 // 100 ticks = 1 Hz flash rate
#define COUNT_MAX		3 // how high to count on the LED display
#define UART_BAUD 115200

/*********************************************************************************
**                            End Of File
*********************************************************************************/\end{verbatim}


\subsection{Driver}

Escrever pequeno texto a respeito do que é o driver

Seguem abaixo os arquivos utilizados:

\subsubsection{gpio.c}

\begin{verbatim}
/****************************************************************************
 *   $Id:: gpio.c 4785 2010-09-03 22:39:27Z nxp21346                        $
 *   Project: NXP LPC11xx GPIO example
 *
 *   Description:
 *     This file contains GPIO code example which include GPIO 
 *     initialization, GPIO interrupt handler, and related APIs for 
 *     GPIO access.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#include "driver_config.h"
#if CONFIG_ENABLE_DRIVER_GPIO==1
#include "gpio.h"

#if CONFIG_GPIO_DEFAULT_PIOINT0_IRQHANDLER==1
volatile uint32_t gpio0_counter = 0;
volatile uint32_t p0_1_counter  = 0;
/*****************************************************************************
** Function name:		PIOINT0_IRQHandler
**
** Descriptions:		Use one GPIO pin(port0 pin1) as interrupt source
**
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void PIOINT0_IRQHandler(void)
{
  uint32_t regVal;

  gpio0_counter++;
  regVal = GPIOIntStatus( PORT0, 1 );
  if ( regVal )
  {
	p0_1_counter++;
	GPIOIntClear( PORT0, 1 );
  }		
  return;
}
#endif

#if CONFIG_GPIO_DEFAULT_PIOINT1_IRQHANDLER==1
volatile uint32_t gpio1_counter = 0;
volatile uint32_t p1_1_counter  = 0;
/*****************************************************************************
** Function name:		PIOINT1_IRQHandler
**
** Descriptions:		Use one GPIO pin(port1 pin1) as interrupt source
**
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void PIOINT1_IRQHandler(void)
{
  uint32_t regVal;

  gpio1_counter++;
  regVal = GPIOIntStatus( PORT1, 1 );
  if ( regVal )
  {
	p1_1_counter++;
	GPIOIntClear( PORT1, 1 );
  }		
  return;
}
#endif

#if CONFIG_GPIO_DEFAULT_PIOINT2_IRQHANDLER==1
volatile uint32_t gpio2_counter = 0;
volatile uint32_t p2_1_counter  = 0;
/*****************************************************************************
** Function name:		PIOINT2_IRQHandler
**
** Descriptions:		Use one GPIO pin(port2 pin1) as interrupt source
**
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void PIOINT2_IRQHandler(void)
{
  uint32_t regVal;

  gpio2_counter++;
  regVal = GPIOIntStatus( PORT2, 1 );
  if ( regVal )
  {
	p2_1_counter++;
	GPIOIntClear( PORT2, 1 );
  }		
  return;
}
#endif

#if CONFIG_GPIO_DEFAULT_PIOINT3_IRQHANDLER==1
volatile uint32_t gpio3_counter = 0;
volatile uint32_t p3_1_counter  = 0;
/*****************************************************************************
** Function name:		PIOINT3_IRQHandler
**
** Descriptions:		Use one GPIO pin(port3 pin1) as interrupt source
**
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void PIOINT3_IRQHandler(void)
{
  uint32_t regVal;

  gpio3_counter++;
  regVal = GPIOIntStatus( PORT3, 1 );
  if ( regVal )
  {
	p3_1_counter++;
	GPIOIntClear( PORT3, 1 );
  }		
  return;
}
#endif //#if CONFIG_GPIO_DEFAULT_PIOINT3_IRQHANDLER==1


/*****************************************************************************
** Function name:		GPIOInit
**
** Descriptions:		Initialize GPIO, install the
**						GPIO interrupt handler
**
** parameters:			None
** Returned value:		true or false, return false if the VIC table
**						is full and GPIO interrupt handler can be
**						installed.
** 
*****************************************************************************/
void GPIOInit( void )
{
  /* Enable AHB clock to the GPIO domain. */
  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<6);

#ifdef __JTAG_DISABLED  
  LPC_IOCON->R_PIO1_1  &= ~0x07;
  LPC_IOCON->R_PIO1_1  |= 0x01;
#endif

  /* Set up NVIC when I/O pins are configured as external interrupts. */
#if CONFIG_GPIO_DEFAULT_PIOINT0_IRQHANDLER==1
  NVIC_EnableIRQ(EINT0_IRQn);
#endif
#if CONFIG_GPIO_DEFAULT_PIOINT1_IRQHANDLER==1
  NVIC_EnableIRQ(EINT1_IRQn);
#endif
#if CONFIG_GPIO_DEFAULT_PIOINT2_IRQHANDLER==1
  NVIC_EnableIRQ(EINT2_IRQn);
#endif
#if CONFIG_GPIO_DEFAULT_PIOINT3_IRQHANDLER==1
  NVIC_EnableIRQ(EINT3_IRQn);
#endif
  return;
}

/*****************************************************************************
** Function name:		GPIOSetInterrupt
**
** Descriptions:		Set interrupt sense, event, etc.
**						edge or level, 0 is edge, 1 is level
**						single or double edge, 0 is single, 1 is double 
**						active high or low, etc.
**
** parameters:			port num, bit position, sense, single/doube, polarity
** Returned value:		None
** 
*****************************************************************************/
void GPIOSetInterrupt( uint32_t portNum, uint32_t bitPosi, uint32_t sense,
			uint32_t single, uint32_t event )
{
  switch ( portNum )
  {
	case PORT0:
	  if ( sense == 0 )
	  {
		LPC_GPIO0->IS &= ~(0x1<<bitPosi);
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
		  LPC_GPIO0->IBE &= ~(0x1<<bitPosi);
		else
		  LPC_GPIO0->IBE |= (0x1<<bitPosi);
	  }
	  else
	  	LPC_GPIO0->IS |= (0x1<<bitPosi);
	  if ( event == 0 )
		LPC_GPIO0->IEV &= ~(0x1<<bitPosi);
	  else
		LPC_GPIO0->IEV |= (0x1<<bitPosi);
	break;
 	case PORT1:
	  if ( sense == 0 )
	  {
		LPC_GPIO1->IS &= ~(0x1<<bitPosi);
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
		  LPC_GPIO1->IBE &= ~(0x1<<bitPosi);
		else
		  LPC_GPIO1->IBE |= (0x1<<bitPosi);
	  }
	  else
	  	LPC_GPIO1->IS |= (0x1<<bitPosi);
	  if ( event == 0 )
		LPC_GPIO1->IEV &= ~(0x1<<bitPosi);
	  else
		LPC_GPIO1->IEV |= (0x1<<bitPosi);  
	break;
	case PORT2:
	  if ( sense == 0 )
	  {
		LPC_GPIO2->IS &= ~(0x1<<bitPosi);
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
		  LPC_GPIO2->IBE &= ~(0x1<<bitPosi);
		else
		  LPC_GPIO2->IBE |= (0x1<<bitPosi);
	  }
	  else
	  	LPC_GPIO2->IS |= (0x1<<bitPosi);
	  if ( event == 0 )
		LPC_GPIO2->IEV &= ~(0x1<<bitPosi);
	  else
		LPC_GPIO2->IEV |= (0x1<<bitPosi);  
	break;
	case PORT3:
	  if ( sense == 0 )
	  {
		LPC_GPIO3->IS &= ~(0x1<<bitPosi);
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
		  LPC_GPIO3->IBE &= ~(0x1<<bitPosi);
		else
		  LPC_GPIO3->IBE |= (0x1<<bitPosi);
	  }
	  else
	  	LPC_GPIO3->IS |= (0x1<<bitPosi);
	  if ( event == 0 )
		LPC_GPIO3->IEV &= ~(0x1<<bitPosi);
	  else
		LPC_GPIO3->IEV |= (0x1<<bitPosi);	  
	break;
	default:
	  break;
  }
  return;
}

/*****************************************************************************
** Function name:		GPIOIntEnable
**
** Descriptions:		Enable Interrupt Mask for a port pin.
**
** parameters:			port num, bit position
** Returned value:		None
** 
*****************************************************************************/
void GPIOIntEnable( uint32_t portNum, uint32_t bitPosi )
{
  switch ( portNum )
  {
	case PORT0:
	  LPC_GPIO0->IE |= (0x1<<bitPosi); 
	break;
 	case PORT1:
	  LPC_GPIO1->IE |= (0x1<<bitPosi);	
	break;
	case PORT2:
	  LPC_GPIO2->IE |= (0x1<<bitPosi);	    
	break;
	case PORT3:
	  LPC_GPIO3->IE |= (0x1<<bitPosi);	    
	break;
	default:
	  break;
  }
  return;
}

/*****************************************************************************
** Function name:		GPIOIntDisable
**
** Descriptions:		Disable Interrupt Mask for a port pin.
**
** parameters:			port num, bit position
** Returned value:		None
** 
*****************************************************************************/
void GPIOIntDisable( uint32_t portNum, uint32_t bitPosi )
{
  switch ( portNum )
  {
	case PORT0:
	  LPC_GPIO0->IE &= ~(0x1<<bitPosi); 
	break;
 	case PORT1:
	  LPC_GPIO1->IE &= ~(0x1<<bitPosi);	
	break;
	case PORT2:
	  LPC_GPIO2->IE &= ~(0x1<<bitPosi);	    
	break;
	case PORT3:
	  LPC_GPIO3->IE &= ~(0x1<<bitPosi);	    
	break;
	default:
	  break;
  }
  return;
}

/*****************************************************************************
** Function name:		GPIOIntStatus
**
** Descriptions:		Get Interrupt status for a port pin.
**
** parameters:			port num, bit position
** Returned value:		None
** 
*****************************************************************************/
uint32_t GPIOIntStatus( uint32_t portNum, uint32_t bitPosi )
{
  uint32_t regVal = 0;

  switch ( portNum )
  {
	case PORT0:
	  if ( LPC_GPIO0->MIS & (0x1<<bitPosi) )
		regVal = 1;
	break;
 	case PORT1:
	  if ( LPC_GPIO1->MIS & (0x1<<bitPosi) )
		regVal = 1;	
	break;
	case PORT2:
	  if ( LPC_GPIO2->MIS & (0x1<<bitPosi) )
		regVal = 1;		    
	break;
	case PORT3:
	  if ( LPC_GPIO3->MIS & (0x1<<bitPosi) )
		regVal = 1;		    
	break;
	default:
	  break;
  }
  return ( regVal );
}

/*****************************************************************************
** Function name:		GPIOIntClear
**
** Descriptions:		Clear Interrupt for a port pin.
**
** parameters:			port num, bit position
** Returned value:		None
** 
*****************************************************************************/
void GPIOIntClear( uint32_t portNum, uint32_t bitPosi )
{
  switch ( portNum )
  {
	case PORT0:
	  LPC_GPIO0->IC |= (0x1<<bitPosi); 
	break;
 	case PORT1:
	  LPC_GPIO1->IC |= (0x1<<bitPosi);	
	break;
	case PORT2:
	  LPC_GPIO2->IC |= (0x1<<bitPosi);	    
	break;
	case PORT3:
	  LPC_GPIO3->IC |= (0x1<<bitPosi);	    
	break;
	default:
	  break;
  }
  return;
}

/*****************************************************************************
** Function name:		GPIOSetValue
**
** Descriptions:		Set/clear a bitvalue in a specific bit position
**						in GPIO portX(X is the port number.)
**
** parameters:			port num, bit position, bit value
** Returned value:		None
**
*****************************************************************************/
void GPIOSetValue( uint32_t portNum, uint32_t bitPosi, uint32_t bitVal )
{
  LPC_GPIO[portNum]->MASKED_ACCESS[(1<<bitPosi)] = (bitVal<<bitPosi);
}

/*****************************************************************************
** Function name:		GPIOSetDir
**
** Descriptions:		Set the direction in GPIO port
**
** parameters:			port num, bit position, direction (1 out, 0 input)
** Returned value:		None
**
*****************************************************************************/
void GPIOSetDir( uint32_t portNum, uint32_t bitPosi, uint32_t dir )
{
  if(dir)
	LPC_GPIO[portNum]->DIR |= 1<<bitPosi;
  else
	LPC_GPIO[portNum]->DIR &= ~(1<<bitPosi);
}
#endif

/******************************************************************************
**                            End Of File
******************************************************************************/ 
\end{verbatim}

\subsubsection{gpio.h}

\begin{verbatim}
/*****************************************************************************
 *   $Id:: gpio.h 4790 2010-09-03 23:35:38Z nxp21346                        $
 *   Project: NXP LPC11xx software example
 *
 *   Description:
 *     This file contains definition and prototype for GPIO.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#ifndef __GPIO_H 
#define __GPIO_H
#if CONFIG_ENABLE_DRIVER_GPIO==1

#define PORT0		0
#define PORT1		1
#define PORT2		2
#define PORT3		3
static LPC_GPIO_TypeDef (* const LPC_GPIO[4]) = { LPC_GPIO0, LPC_GPIO1, LPC_GPIO2, LPC_GPIO3 };
void PIOINT0_IRQHandler(void);
void PIOINT1_IRQHandler(void);
void PIOINT2_IRQHandler(void);
void PIOINT3_IRQHandler(void);
void GPIOInit( void );
void GPIOSetInterrupt( uint32_t portNum, uint32_t bitPosi, uint32_t sense,
		uint32_t single, uint32_t event );

void GPIOIntEnable( uint32_t portNum, uint32_t bitPosi );
void GPIOIntDisable( uint32_t portNum, uint32_t bitPosi );
uint32_t GPIOIntStatus( uint32_t portNum, uint32_t bitPosi );
void GPIOIntClear( uint32_t portNum, uint32_t bitPosi );
void GPIOSetValue( uint32_t portNum, uint32_t bitPosi, uint32_t bitVal );
void GPIOSetDir( uint32_t portNum, uint32_t bitPosi, uint32_t dir );
#endif
#endif /* end __GPIO_H */
/*****************************************************************************
**                            End Of File
******************************************************************************/ 
\end{verbatim}

\subsubsection{i2c\_driver.c}

\begin{verbatim}
/****************************************************************************
 *   $Id:: i2c.c 5796 2010-12-03 00:08:56Z nxp21346                         $
 *   Project: NXP LPC11xx I2C example
 *
 *   Description:
 *     This file contains I2C code example which include I2C initialization, 
 *     I2C interrupt handler, and APIs for I2C access.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#include "driver_config.h"
#if CONFIG_ENABLE_DRIVER_I2C==1
#include "type.h"
#include "i2c_driver.h"

volatile uint32_t I2CMasterState = I2C_IDLE;
volatile uint32_t I2CSlaveState = I2C_IDLE;
volatile uint32_t timeout = 0;

volatile uint32_t I2CMode;

volatile uint8_t I2CMasterBuffer[I2C_BUFSIZE];
volatile uint8_t I2CSlaveBuffer[I2C_BUFSIZE];
volatile uint32_t I2CCount = 0;
volatile uint32_t I2CReadLength;
volatile uint32_t I2CWriteLength;

volatile uint32_t RdIndex = 0;
volatile uint32_t WrIndex = 0;

#if CONFIG_I2C_DEFAULT_I2C_IRQHANDLER==1
/* 
From device to device, the I2C communication protocol may vary, 
in the example below, the protocol uses repeated start to read data from or 
write to the device:
For master read: the sequence is: STA,Addr(W),offset,RE-STA,Addr(r),data...STO 
for master write: the sequence is: STA,Addr(W),offset,RE-STA,Addr(w),data...STO
Thus, in state 8, the address is always WRITE. in state 10, the address could 
be READ or WRITE depending on the I2C command.
*/   

/*****************************************************************************
** Function name:		I2C_IRQHandler
**
** Descriptions:		I2C interrupt handler, deal with master mode only.
**
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void I2C_IRQHandler(void) 
{
  uint8_t StatValue;

  timeout = 0;
  /* this handler deals with master read and master write only */
  StatValue = LPC_I2C->STAT;
  switch ( StatValue )
  {
	case 0x08:			/* A Start condition is issued. */
	WrIndex = 0;
	LPC_I2C->DAT = I2CMasterBuffer[WrIndex++];
	LPC_I2C->CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC);
	break;
	
	case 0x10:			/* A repeated started is issued */
	RdIndex = 0;
	/* Send SLA with R bit set, */
	LPC_I2C->DAT = I2CMasterBuffer[WrIndex++];
	LPC_I2C->CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC);
	break;
	
	case 0x18:			/* Regardless, it's a ACK */
	if ( I2CWriteLength == 1 )
	{
	  LPC_I2C->CONSET = I2CONSET_STO;      /* Set Stop flag */
	  I2CMasterState = I2C_NO_DATA;
	}
	else
	{
	  LPC_I2C->DAT = I2CMasterBuffer[WrIndex++];
	}
	LPC_I2C->CONCLR = I2CONCLR_SIC;
	break;
	
	case 0x28:	/* Data byte has been transmitted, regardless ACK or NACK */
	if ( WrIndex < I2CWriteLength )
	{   
	  LPC_I2C->DAT = I2CMasterBuffer[WrIndex++]; /* this should be the last one */
	}
	else
	{
	  if ( I2CReadLength != 0 )
	  {
		LPC_I2C->CONSET = I2CONSET_STA;	/* Set Repeated-start flag */
	  }
	  else
	  {
		LPC_I2C->CONSET = I2CONSET_STO;      /* Set Stop flag */
		I2CMasterState = I2C_OK;
	  }
	}
	LPC_I2C->CONCLR = I2CONCLR_SIC;
	break;
	
	case 0x30:
	LPC_I2C->CONSET = I2CONSET_STO;      /* Set Stop flag */
	I2CMasterState = I2C_NACK_ON_DATA;
	LPC_I2C->CONCLR = I2CONCLR_SIC;
	break;
	
	case 0x40:	/* Master Receive, SLA_R has been sent */
	if ( (RdIndex + 1) < I2CReadLength )
	{
	  /* Will go to State 0x50 */
	  LPC_I2C->CONSET = I2CONSET_AA;	/* assert ACK after data is received */
	}
	else
	{
	  /* Will go to State 0x58 */
	  LPC_I2C->CONCLR = I2CONCLR_AAC;	/* assert NACK after data is received */
	}
	LPC_I2C->CONCLR = I2CONCLR_SIC;
	break;
	
	case 0x50:	/* Data byte has been received, regardless following ACK or NACK */
	I2CSlaveBuffer[RdIndex++] = LPC_I2C->DAT;
	if ( (RdIndex + 1) < I2CReadLength )
	{   
	  LPC_I2C->CONSET = I2CONSET_AA;	/* assert ACK after data is received */
	}
	else
	{
	  LPC_I2C->CONCLR = I2CONCLR_AAC;	/* assert NACK on last byte */
	}
	LPC_I2C->CONCLR = I2CONCLR_SIC;
	break;
	
	case 0x58:
	I2CSlaveBuffer[RdIndex++] = LPC_I2C->DAT;
	I2CMasterState = I2C_OK;
	LPC_I2C->CONSET = I2CONSET_STO;	/* Set Stop flag */ 
	LPC_I2C->CONCLR = I2CONCLR_SIC;	/* Clear SI flag */
	break;

	case 0x20:		/* regardless, it's a NACK */
	case 0x48:
	LPC_I2C->CONSET = I2CONSET_STO;      /* Set Stop flag */
	I2CMasterState = I2C_NACK_ON_ADDRESS;
	LPC_I2C->CONCLR = I2CONCLR_SIC;
	break;
	
	case 0x38:		/* Arbitration lost, in this example, we don't
					deal with multiple master situation */
	default:
	I2CMasterState = I2C_ARBITRATION_LOST;
	LPC_I2C->CONCLR = I2CONCLR_SIC;	
	break;
  }
  return;
}
#endif

/*****************************************************************************
** Function name:		I2CStart
**
** Descriptions:		Create I2C start condition, a timeout
**				value is set if the I2C never gets started,
**				and timed out. It's a fatal error. 
**
** parameters:			None
** Returned value:		true or false, return false if timed out
** 
*****************************************************************************/
uint32_t I2CStart( void )
{
  uint32_t timeout = 0;
  uint32_t retVal = FALSE;
 
  /*--- Issue a start condition ---*/
  LPC_I2C->CONSET = I2CONSET_STA;	/* Set Start flag */
    
  /*--- Wait until START transmitted ---*/
  while( 1 )
  {
	if ( I2CMasterState == I2C_STARTED )
	{
	  retVal = TRUE;
	  break;	
	}
	if ( timeout >= MAX_TIMEOUT )
	{
	  retVal = FALSE;
	  break;
	}
	timeout++;
  }
  return( retVal );
}

/*****************************************************************************
** Function name:		I2CStop
**
** Descriptions:		Set the I2C stop condition, if the routine
**				never exit, it's a fatal bus error.
**
** parameters:			None
** Returned value:		true or never return
** 
*****************************************************************************/
uint32_t I2CStop( void )
{
  LPC_I2C->CONSET = I2CONSET_STO;      /* Set Stop flag */ 
  LPC_I2C->CONCLR = I2CONCLR_SIC;  /* Clear SI flag */ 
            
  /*--- Wait for STOP detected ---*/
  while( LPC_I2C->CONSET & I2CONSET_STO );
  return TRUE;
}

/*****************************************************************************
** Function name:		I2CInit
**
** Descriptions:		Initialize I2C controller
**
** parameters:			I2c mode is either MASTER or SLAVE
** Returned value:		true or false, return false if the I2C
**				interrupt handler was not installed correctly
** 
*****************************************************************************/
uint32_t I2CInit( uint32_t I2cMode ) 
{
  LPC_SYSCON->PRESETCTRL |= (0x1<<1);

  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<5);
  LPC_IOCON->PIO0_4 &= ~0x3F;	/*  I2C I/O config */
  LPC_IOCON->PIO0_4 |= 0x01;		/* I2C SCL */
  LPC_IOCON->PIO0_5 &= ~0x3F;	
  LPC_IOCON->PIO0_5 |= 0x01;		/* I2C SDA */
  /* IOCON may change in the next release, save change for future references. */
//  LPC_IOCON->PIO0_4 |= (0x1<<10);	/* open drain pins */
//  LPC_IOCON->PIO0_5 |= (0x1<<10);	/* open drain pins */

  /*--- Clear flags ---*/
  LPC_I2C->CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC;    

  /*--- Reset registers ---*/
#if FAST_MODE_PLUS
  LPC_IOCON->PIO0_4 |= (0x2<<8);
  LPC_IOCON->PIO0_5 |= (0x2<<8);
  LPC_I2C->SCLL   = I2SCLL_HS_SCLL;
  LPC_I2C->SCLH   = I2SCLH_HS_SCLH;
#else
  LPC_I2C->SCLL   = I2SCLL_SCLL;
  LPC_I2C->SCLH   = I2SCLH_SCLH;
#endif

  if ( I2cMode == I2CSLAVE )
  {
	LPC_I2C->ADR0 = PCF8594_ADDR;
  }    

  /* Enable the I2C Interrupt */
  NVIC_EnableIRQ(I2C_IRQn);

  LPC_I2C->CONSET = I2CONSET_I2EN;
  return( TRUE );
}

/*****************************************************************************
** Function name:		I2CEngine
**
** Descriptions:		The routine to complete a I2C transaction
**				from start to stop. All the intermittent
**				steps are handled in the interrupt handler.
**				Before this routine is called, the read
**				length, write length, I2C master buffer,
**				and I2C command fields need to be filled.
**				see i2cmst.c for more details. 
**
** parameters:			None
** Returned value:		true or false, return false only if the
**				start condition can never be generated and
**				timed out. 
** 
*****************************************************************************/
uint32_t I2CEngine( void ) 
{
  RdIndex = 0;
  WrIndex = 0;

  /*--- Issue a start condition ---*/
  LPC_I2C->CONSET = I2CONSET_STA;	/* Set Start flag */

  I2CMasterState = I2C_BUSY;	

  while ( I2CMasterState == I2C_BUSY )
  {
	if ( timeout >= MAX_TIMEOUT )
	{
	  I2CMasterState = I2C_TIME_OUT;
	  break;
	}
	timeout++;
  }    
  LPC_I2C->CONCLR = I2CONCLR_STAC;

  return ( I2CMasterState );
}
#endif

/******************************************************************************
**                            End Of File
******************************************************************************/
 
\end{verbatim}

\subsubsection{i2c\_driver.h}

\begin{verbatim}
/****************************************************************************
 *   $Id:: i2c.h 4785 2010-09-03 22:39:27Z nxp21346                         $
 *   Project: NXP LPC11xx I2C example
 *
 *   Description:
 *     This file contains I2C code header definition.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#ifndef __I2C_DRIVER_H
#define __I2C_DRIVER_H
#if CONFIG_ENABLE_DRIVER_I2C==1

/* If I2C SEEPROM is tested, make sure FAST_MODE_PLUS is 0.
For board to board test, this flag can be turned on. */

#define FAST_MODE_PLUS	0

#define I2C_BUFSIZE             64
#define MAX_TIMEOUT		0x00FFFFFF

#define I2CMASTER		0x01
#define I2CSLAVE		0x02

#define PCF8594_ADDR	0xA0
#define READ_WRITE		0x01

#define RD_BIT			0x01

#define I2C_IDLE			0
#define I2C_STARTED			1
#define I2C_RESTARTED		2
#define I2C_REPEATED_START	3
#define DATA_ACK			4
#define DATA_NACK			5
#define I2C_BUSY              6
#define I2C_NO_DATA           7
#define I2C_NACK_ON_ADDRESS   8
#define I2C_NACK_ON_DATA      9
#define I2C_ARBITRATION_LOST  10
#define I2C_TIME_OUT          11
#define I2C_OK                12

#define I2CONSET_I2EN       (0x1<<6)  /* I2C Control Set Register */
#define I2CONSET_AA         (0x1<<2)
#define I2CONSET_SI         (0x1<<3)
#define I2CONSET_STO        (0x1<<4)
#define I2CONSET_STA        (0x1<<5)

#define I2CONCLR_AAC        (0x1<<2)  /* I2C Control clear Register */
#define I2CONCLR_SIC        (0x1<<3)
#define I2CONCLR_STAC       (0x1<<5)
#define I2CONCLR_I2ENC      (0x1<<6)

#define I2DAT_I2C			0x00000000  /* I2C Data Reg */
#define I2ADR_I2C			0x00000000  /* I2C Slave Address Reg */
#define I2SCLH_SCLH			0x00000180  /* I2C SCL Duty Cycle High Reg */
#define I2SCLL_SCLL			0x00000180  /* I2C SCL Duty Cycle Low Reg */
#define I2SCLH_HS_SCLH		0x00000015  /* Fast Plus I2C SCL Duty Cycle High Reg */
#define I2SCLL_HS_SCLL		0x00000015  /* Fast Plus I2C SCL Duty Cycle Low Reg */

#if CONFIG_I2C_DEFAULT_I2C_IRQHANDLER==1
extern void I2C_IRQHandler( void );
#endif
extern uint32_t I2CInit( uint32_t I2cMode );
extern uint32_t I2CStart( void );
extern uint32_t I2CStop( void );
extern uint32_t I2CEngine( void );

#endif
#endif /* end __I2C_DRIVER_H */
/****************************************************************************
**                            End Of File
*****************************************************************************/ 
\end{verbatim}

\subsubsection{timer16.c}

\begin{verbatim}
 /****************************************************************************
 *   $Id:: timer16.c 4785 2010-09-03 22:39:27Z nxp21346                     $
 *   Project: NXP LPC11xx 16-bit timer example
 *
 *   Description:
 *     This file contains 16-bit timer code example which include timer 
 *     initialization, timer interrupt handler, and related APIs for 
 *     timer setup.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#include "driver_config.h"
#include "timer16.h"

#if CONFIG_ENABLE_DRIVER_TIMER16==1
volatile uint32_t timer16_0_period = 0;
#ifdef CONFIG_TIMER16_DEFAULT_TIMER16_0_IRQHANDLER
volatile uint32_t timer16_0_counter = 0;
volatile uint32_t timer16_0_capture = 0;
#endif
volatile uint32_t timer16_1_period = 0;
#ifdef CONFIG_TIMER16_DEFAULT_TIMER16_1_IRQHANDLER
volatile uint32_t timer16_1_counter = 0;
volatile uint32_t timer16_1_capture = 0;
#endif

/*****************************************************************************
** Function name:		delayMs
**
** Descriptions:		Start the timer delay in milo seconds
**						until elapsed
**
** parameters:			timer number, Delay value in milo second			 
** 						
** Returned value:		None
** 
*****************************************************************************/
void delayMs(uint8_t timer_num, uint32_t delayInMs)
{
  if (timer_num == 0)
  {
    /*
    * setup timer #0 for delay
    */
    LPC_TMR16B0->TCR = 0x02;		/* reset timer */
    LPC_TMR16B0->PR  = KHZ_PRESCALE; /* set prescaler to get 1 K counts/sec */
    LPC_TMR16B0->MR0 = delayInMs * TIME_INTERVALmS_KHZ_CLOCK;
    LPC_TMR16B0->IR  = 0xff;		/* reset all interrrupts */
    LPC_TMR16B0->MCR = 0x04;		/* stop timer on match */
    LPC_TMR16B0->TCR = 0x01;		/* start timer */
    /* wait until delay time has elapsed */
    while (LPC_TMR16B0->TCR & 0x01);
  }
  else if (timer_num == 1)
  {
    /*
    * setup timer #1 for delay
    */
    LPC_TMR16B1->TCR = 0x02;		/* reset timer */
    LPC_TMR16B1->PR  = KHZ_PRESCALE; /* set prescaler to get 1 K counts/sec */
    LPC_TMR16B1->MR0 = delayInMs * TIME_INTERVALmS_KHZ_CLOCK;
    LPC_TMR16B1->IR  = 0xff;		/* reset all interrrupts */
    LPC_TMR16B1->MCR = 0x04;		/* stop timer on match */
    LPC_TMR16B1->TCR = 0x01;		/* start timer */
    /* wait until delay time has elapsed */
    while (LPC_TMR16B1->TCR & 0x01);
  }
  return;
}

/******************************************************************************
** Function name:		TIMER16_0_IRQHandler
**
** Descriptions:		Timer/Counter 0 interrupt handler
**						executes each 10ms @ 60 MHz CPU Clock
**
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
#if CONFIG_TIMER16_DEFAULT_TIMER16_0_IRQHANDLER==1
void TIMER16_0_IRQHandler(void)
{  
  if ( LPC_TMR16B0->IR & 0x1 )
  {
  LPC_TMR16B0->IR = 1;			/* clear interrupt flag */
  timer16_0_counter++;
  }
  if ( LPC_TMR16B0->IR & (0x1<<4) )
  {
	LPC_TMR16B0->IR = 0x1<<4;		/* clear interrupt flag */
	timer16_0_capture++;
  }
  return;
}
#endif

#if CONFIG_TIMER16_DEFAULT_TIMER16_1_IRQHANDLER==1
/******************************************************************************
** Function name:		TIMER16_1_IRQHandler
**
** Descriptions:		Timer/Counter 1 interrupt handler
**						executes each 10ms @ 60 MHz CPU Clock
**
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void TIMER16_1_IRQHandler(void)
{  
  if ( LPC_TMR16B1->IR & 0x1 )
  {  
  LPC_TMR16B1->IR = 1;			/* clear interrupt flag */
  timer16_1_counter++;
  }
  if ( LPC_TMR16B1->IR & (0x1<<4) )
  {
	LPC_TMR16B1->IR = 0x1<<4;		/* clear interrupt flag */
	timer16_1_capture++;
  }
  return;
}
#endif

/******************************************************************************
** Function name:		enable_timer
**
** Descriptions:		Enable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void enable_timer16(uint8_t timer_num)
{
  if ( timer_num == 0 )
  {
    LPC_TMR16B0->TCR = 1;
  }
  else
  {
    LPC_TMR16B1->TCR = 1;
  }
  return;
}

/******************************************************************************
** Function name:		disable_timer
**
** Descriptions:		Disable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void disable_timer16(uint8_t timer_num)
{
  if ( timer_num == 0 )
  {
    LPC_TMR16B0->TCR = 0;
  }
  else
  {
    LPC_TMR16B1->TCR = 0;
  }
  return;
}

/******************************************************************************
** Function name:		reset_timer
**
** Descriptions:		Reset timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void reset_timer16(uint8_t timer_num)
{
  uint32_t regVal;

  if ( timer_num == 0 )
  {
    regVal = LPC_TMR16B0->TCR;
    regVal |= 0x02;
    LPC_TMR16B0->TCR = regVal;
  }
  else
  {
    regVal = LPC_TMR16B1->TCR;
    regVal |= 0x02;
    LPC_TMR16B1->TCR = regVal;
  }
  return;
}

/******************************************************************************
** Function name:		init_timer
**
** Descriptions:		Initialize timer, set timer interval, reset timer,
**						install timer interrupt handler
**
** parameters:			timer number and timer interval
** Returned value:		None
** 
******************************************************************************/
void init_timer16(uint8_t timer_num, uint16_t TimerInterval)
{
  if ( timer_num == 0 )
  {
    /* Some of the I/O pins need to be clearfully planned if
    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);
    LPC_IOCON->PIO0_2           &= ~0x07;	/*  Timer0_16 I/O config */
    LPC_IOCON->PIO0_2           |= 0x02;		/* Timer0_16 CAP0 */
    LPC_IOCON->PIO0_8           &= ~0x07;	
    LPC_IOCON->PIO0_8           |= 0x02;		/* Timer0_16 MAT0 */
    LPC_IOCON->PIO0_9           &= ~0x07;
    LPC_IOCON->PIO0_9           |= 0x02;		/* Timer0_16 MAT1 */
#ifdef __JTAG_DISABLED
    LPC_IOCON->JTAG_TCK_PIO0_10 &= ~0x07;
    LPC_IOCON->JTAG_TCK_PIO0_10 |= 0x03;		/* Timer0_16 MAT2 */
#endif	
#if CONFIG_TIMER16_DEFAULT_TIMER16_0_IRQHANDLER==1
    timer16_0_counter = 0;
	timer16_0_capture = 0;
#endif
    LPC_TMR16B0->PR  = KHZ_PRESCALE; /* set prescaler to get 1 K counts/sec */
    LPC_TMR16B0->MR0 = TimerInterval;
#if TIMER_MATCH
	LPC_TMR16B0->EMR &= ~(0xFF<<4);
	LPC_TMR16B0->EMR |= ((0x3<<4)|(0x3<<6));
#else
	/* Capture 0 on rising edge, interrupt enable. */
	LPC_TMR16B0->CCR = (0x1<<0)|(0x1<<2);
#endif
    LPC_TMR16B0->MCR = 0x03;				/* Interrupt and Reset on MR0 and MR1 */

#if CONFIG_TIMER16_DEFAULT_TIMER16_0_IRQHANDLER==1
    /* Enable the TIMER0 Interrupt */
    NVIC_EnableIRQ(TIMER_16_0_IRQn);
#endif
  }
  else if ( timer_num == 1 )
  {
    /* Some of the I/O pins need to be clearfully planned if
    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);
//    LPC_IOCON->PIO1_8           &= ~0x07;	/*  Timer1_16 I/O config */
//    LPC_IOCON->PIO1_8           |= 0x01;		/* Timer1_16 CAP0 */
//    LPC_IOCON->PIO1_9           &= ~0x07;
    LPC_IOCON->PIO1_9           &= ~0x1F;
    LPC_IOCON->PIO1_9           |= 0x01;		/* Timer1_16 MAT0 */
//    LPC_IOCON->PIO1_10          &= ~0x07;
    LPC_IOCON->PIO1_10          &= ~0x1F;
    LPC_IOCON->PIO1_10          |= 0x02;		/* Timer1_16 MAT1 */	
#if CONFIG_TIMER16_DEFAULT_TIMER16_1_IRQHANDLER==1
    timer16_1_counter = 0;
	timer16_1_capture = 0;
#endif
    LPC_TMR16B1->TCR = 0x02;          /* reset timer */
    LPC_TMR16B1->PR  = KHZ_PRESCALE;  /* set prescaler to get 1 K counts/sec */
    LPC_TMR16B1->MR0 = TimerInterval; /* Set up 100 mS interval */
#if TIMER_MATCH
	LPC_TMR16B1->EMR &= ~(0xFF<<4);
	LPC_TMR16B1->EMR |= ((0x3<<4)|(0x3<<6));
#else
	/* Capture 0 on rising edge, interrupt enable. */
	LPC_TMR16B1->CCR = (0x1<<0)|(0x1<<2);
#endif
    LPC_TMR16B1->MCR = 0x03;          /* Interrupt and Reset on MR0 and MR1 */
#if CONFIG_TIMER16_DEFAULT_TIMER16_1_IRQHANDLER==1
    /* Enable the TIMER1 Interrupt */
    NVIC_EnableIRQ(TIMER_16_1_IRQn);
#endif
  }
  return;
}
/******************************************************************************
** Function name:		init_timer16PWM
**
** Descriptions:		Initialize timer as PWM
**
** parameters:			timer number, period and match enable:
**										match_enable[0] = PWM for MAT0 
**										match_enable[1] = PWM for MAT1
**										match_enable[2] = PWM for MAT2
**			
** Returned value:		None
** 
******************************************************************************/
void init_timer16PWM(uint8_t timer_num, uint32_t period, uint8_t match_enable, uint8_t cap_enabled)
{
	
//	NVIC_InitTypeDef NVIC_InitStructure;
	
	disable_timer16(timer_num);

	if (timer_num == 1)
	{
		/* Some of the I/O pins need to be clearfully planned if
		you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
		LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);
		
		/* Setup the external match register */
		LPC_TMR16B1->EMR = (1<<EMC3)|(1<<EMC2)|(1<<EMC1)|(2<<EMC0)|(1<<3)|(match_enable);
		
		/* Setup the outputs */
		/* If match0 is enabled, set the output */
		if (match_enable & 0x01)
		{
			LPC_IOCON->PIO1_9           &= ~0x07;	
			LPC_IOCON->PIO1_9           |= 0x01;		/* Timer1_16 MAT0 */
		}
		/* If match1 is enabled, set the output */
		if (match_enable & 0x02)
		{
			LPC_IOCON->PIO1_10          &= ~0x07;
			LPC_IOCON->PIO1_10          |= 0x02;		/* Timer1_16 MAT1 */
		}
		
		/* Enable the selected PWMs and enable Match3 */
		LPC_TMR16B1->PWMC = (1<<3)|(match_enable);
		
		/* Setup the match registers */
		/* set the period value to a global variable */
		timer16_1_period 	= period;
		LPC_TMR16B1->MR3 	= timer16_1_period;
		LPC_TMR16B1->MR0	= timer16_1_period/2;
		LPC_TMR16B1->MR1	= timer16_1_period/2;
		LPC_TMR16B1->MR2	= timer16_1_period/2;
		
		/* Set match control register */
		LPC_TMR16B1->MCR = 1<<10;// | 1<<9;				/* Reset on MR3 */
		
		if (cap_enabled)
		{
			LPC_IOCON->PIO1_8 &= ~0x07;						/*  Timer1_16 I/O config */
			LPC_IOCON->PIO1_8 |= 0x01 | (2<<3);				/* Timer1_16 CAP0 */
			LPC_GPIO1->DIR &= ~(1<<8); 
			LPC_TMR16B1->IR = 0xF;							/* clear interrupt flag */
			
			/* Set the capture control register */
			LPC_TMR16B1->CCR = 7;
			
		}
		/* Enable the TIMER1 Interrupt */
		NVIC_EnableIRQ(TIMER_16_1_IRQn);
	}
	else
	{
		/* Some of the I/O pins need to be clearfully planned if
		you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
		LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);
		
		/* Setup the external match register */
		LPC_TMR16B0->EMR = (1<<EMC3)|(1<<EMC2)|(1<<EMC1)|(1<<EMC0)|(1<<3)|(match_enable);
		
		/* Setup the outputs */
		/* If match0 is enabled, set the output */
		if (match_enable & 0x01)
		{
			LPC_IOCON->PIO0_8           &= ~0x07;	
			LPC_IOCON->PIO0_8           |= 0x02;		/* Timer0_16 MAT0 			*/
		}
		/* If match1 is enabled, set the output */
		if (match_enable & 0x02)
		{
			LPC_IOCON->PIO0_9           &= ~0x07;
			LPC_IOCON->PIO0_9           |= 0x02;		/* Timer0_16 MAT1 			*/
		}
		/* If match2 is enabled, set the output */
		if (match_enable & 0x04)
		{
			LPC_IOCON->SWCLK_PIO0_10 &= ~0x07;
			LPC_IOCON->SWCLK_PIO0_10 |= 0x03;		/* Timer0_16 MAT2 */
		}
		
		//	  PIO0_2           &= ~0x07;	/* Timer0_16 I/O config */
		//	  PIO0_2           |= 0x02;		/* Timer0_16 CAP0 			*/
		
		/* Enable the selected PWMs and enable Match3 */
		LPC_TMR16B0->PWMC = (1<<3)|(match_enable);
		LPC_TMR16B0->PR = KHZ_PRESCALE/3000;  /* set prescaler to get 100 counts/sec */
		
		/* Setup the match registers */
		/* set the period value to a global variable */
		timer16_0_period = period;
		LPC_TMR16B0->MR3 = timer16_0_period;
		LPC_TMR16B0->MR0	= timer16_0_period/2;
		LPC_TMR16B0->MR1	= timer16_0_period/2;
		LPC_TMR16B0->MR2	= timer16_0_period/2;
		
		/* Set the match control register */
		LPC_TMR16B0->MCR = 1<<10;				/* Reset on MR3 */
		
		/* Enable the TIMER1 Interrupt */
		NVIC_EnableIRQ(TIMER_16_0_IRQn);
	}

}
/******************************************************************************
** Function name:		pwm16_setMatch
**
** Descriptions:		Set the pwm16 match values
**
** parameters:			timer number, match numner and the value
**
** Returned value:		None
** 
******************************************************************************/
void setMatch_timer16PWM (uint8_t timer_num, uint8_t match_nr, uint32_t value)
{
	if (timer_num)
	{
		switch (match_nr)
		{
			case 0:
				LPC_TMR16B1->MR0 = value;
				break;
			case 1: 
				LPC_TMR16B1->MR1 = value;
				break;
			case 2:
				LPC_TMR16B1->MR2 = value;
				break;
			case 3: 
				LPC_TMR16B1->MR3 = value;
				break;
			default:
				break;
		}	

	}
	else 
	{
		switch (match_nr)
		{
			case 0:
				LPC_TMR16B0->MR0 = value;
				break;
			case 1: 
				LPC_TMR16B0->MR1 = value;
				break;
			case 2:
				LPC_TMR16B0->MR2 = value;
				break;
			case 3: 
				LPC_TMR16B0->MR3 = value;
				break;
			default:
				break;
		}	
	}

}

#endif
/******************************************************************************
**                            End Of File
******************************************************************************/
\end{verbatim}

\subsubsection{timer16.h}

\begin{verbatim}
 /****************************************************************************
 *   $Id:: timer16.h 4785 2010-09-03 22:39:27Z nxp21346                     $
 *   Project: NXP LPC11xx 16-bit timer example
 *
 *   Description:
 *     This file contains 16-bit timer code example which include timer 
 *     initialization, timer interrupt handler, and related APIs for 
 *     timer setup.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#ifndef __TIMER16_H 
#define __TIMER16_H
#if CONFIG_ENABLE_DRIVER_TIMER16==1

/* TIMER_CLOCKFREQ is the clock rate into the timer prescaler */
#define TIMER_CLOCKFREQ SystemCoreClock

/* MHZ_PRESCALE is a value to set the prescaler to in order to
   clock the timer at 1 MHz. Clock needs to be a multiple of 1 MHz or
   this will not work. */
#define MHZ_PRESCALE    (TIMER_CLOCKFREQ/1000000 -1)
#define KHZ_PRESCALE    (TIMER_CLOCKFREQ/1000 -1)

/* TIME_INTERVALmS is a value to load the timer match register with
   to get a 1 mS delay */
#define TIME_INTERVALmS_MHZ_CLOCK	1000
#define TIME_INTERVALmS_KHZ_CLOCK   1

/* The test is either MAT_OUT or CAP_IN. Default is MAT_OUT. */
#define TIMER_MATCH		0

void delayMs(uint8_t timer_num, uint32_t delayInMs);

#define EMC0	4
#define EMC1	6
#define EMC2	8
#define EMC3	10

#define MATCH0	(1<<0)
#define MATCH1	(1<<1)
#define MATCH2	(1<<2)
#define MATCH3	(1<<3)

void TIMER16_0_IRQHandler(void);
void TIMER16_1_IRQHandler(void);

void enable_timer16(uint8_t timer_num);
void disable_timer16(uint8_t timer_num);
void reset_timer16(uint8_t timer_num);
void init_timer16(uint8_t timer_num, uint16_t timerInterval);
void init_timer16PWM(uint8_t timer_num, uint32_t period, uint8_t match_enable, uint8_t cap_enabled);
void setMatch_timer16PWM (uint8_t timer_num, uint8_t match_nr, uint32_t value);

#endif
#endif /* end __TIMER16_H */
/*****************************************************************************
**                            End Of File
******************************************************************************/
\end{verbatim}

\subsubsection{timer32.c}

\begin{verbatim}
/****************************************************************************
 *   $Id:: timer32.c 4785 2010-09-03 22:39:27Z nxp21346                     $
 *   Project: NXP LPC11xx 32-bit timer example
 *
 *   Description:
 *     This file contains 32-bit timer code example which include timer 
 *     initialization, timer interrupt handler, and related APIs for 
 *     timer setup.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#include "driver_config.h"
#if CONFIG_ENABLE_DRIVER_TIMER32==1
#include "timer32.h"

/* ===================
 * CodeRed - Modified file to extract out interrupt handler related code,
 * which is really application project specific.
 * Set TIMER32_GENERIC_INTS to 1 to reenable original code.
 * =================== */
volatile uint32_t timer32_0_period = 0;
#ifdef CONFIG_TIMER32_DEFAULT_TIMER32_0_IRQHANDLER
volatile uint32_t timer32_0_counter = 0;
volatile uint32_t timer32_0_capture = 0;
#endif //CONFIG_TIMER32_DEFAULT_TIMER32_0_IRQHANDLER

volatile uint32_t timer32_1_period = 0;
#ifdef CONFIG_TIMER32_DEFAULT_TIMER32_1_IRQHANDLER
volatile uint32_t timer32_1_counter = 0;
volatile uint32_t timer32_1_capture = 0;
#endif //CONFIG_TIMER32_DEFAULT_TIMER32_1_IRQHANDLER

/*****************************************************************************
** Function name:		delay32Ms
**
** Descriptions:		Start the timer delay in milo seconds
**						until elapsed
**
** parameters:			timer number, Delay value in milo second			 
** 						
** Returned value:		None
** 
*****************************************************************************/
void delay32Ms(uint8_t timer_num, uint32_t delayInMs)
{
  if (timer_num == 0)
  {
    /* setup timer #0 for delay */
    LPC_TMR32B0->TCR = 0x02;		/* reset timer */
    LPC_TMR32B0->PR  = 0x00;		/* set prescaler to zero */
    LPC_TMR32B0->MR0 = delayInMs * ((SystemCoreClock/(LPC_TMR32B0->PR+1)) / 1000);
    LPC_TMR32B0->IR  = 0xff;		/* reset all interrrupts */
    LPC_TMR32B0->MCR = 0x04;		/* stop timer on match */
    LPC_TMR32B0->TCR = 0x01;		/* start timer */
  
    /* wait until delay time has elapsed */
    while (LPC_TMR32B0->TCR & 0x01);
  }
  else if (timer_num == 1)
  {
    /* setup timer #1 for delay */
    LPC_TMR32B1->TCR = 0x02;		/* reset timer */
    LPC_TMR32B1->PR  = 0x00;		/* set prescaler to zero */
    LPC_TMR32B1->MR0 = delayInMs * ((SystemCoreClock/(LPC_TMR32B0->PR+1)) / 1000);
    LPC_TMR32B1->IR  = 0xff;		/* reset all interrrupts */
    LPC_TMR32B1->MCR = 0x04;		/* stop timer on match */
    LPC_TMR32B1->TCR = 0x01;		/* start timer */
  
    /* wait until delay time has elapsed */
    while (LPC_TMR32B1->TCR & 0x01);
  }
  return;
}


#if CONFIG_TIMER32_DEFAULT_TIMER32_0_IRQHANDLER==1
/******************************************************************************
** Function name:		TIMER32_0_IRQHandler
**
** Descriptions:		Timer/Counter 0 interrupt handler
**						executes each 10ms @ 60 MHz CPU Clock
**
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void TIMER32_0_IRQHandler(void)
{  
  if ( LPC_TMR32B0->IR & 0x01 )
  {  
	LPC_TMR32B0->IR = 1;				/* clear interrupt flag */
	timer32_0_counter++;
  }
  if ( LPC_TMR32B0->IR & (0x1<<4) )
  {  
	LPC_TMR32B0->IR = 0x1<<4;			/* clear interrupt flag */
	timer32_0_capture++;
  }
  return;
}
#endif //CONFIG_TIMER32_DEFAULT_TIMER32_0_IRQHANDLER

#if CONFIG_TIMER32_DEFAULT_TIMER32_1_IRQHANDLER==1
/******************************************************************************
** Function name:		TIMER32_1_IRQHandler
**
** Descriptions:		Timer/Counter 1 interrupt handler
**						executes each 10ms @ 60 MHz CPU Clock
**
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void TIMER32_1_IRQHandler(void)
{  
  if ( LPC_TMR32B1->IR & 0x01 )
  {    
	LPC_TMR32B1->IR = 1;			/* clear interrupt flag */
	timer32_1_counter++;
  }
  if ( LPC_TMR32B1->IR & (0x1<<4) )
  {  
	LPC_TMR32B1->IR = 0x1<<4;			/* clear interrupt flag */
	timer32_1_capture++;
  }
  return;
}
#endif //CONFIG_TIMER32_DEFAULT_TIMER32_1_IRQHANDLER

/******************************************************************************
** Function name:		enable_timer
**
** Descriptions:		Enable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void enable_timer32(uint8_t timer_num)
{
  if ( timer_num == 0 )
  {
    LPC_TMR32B0->TCR = 1;
  }
  else
  {
    LPC_TMR32B1->TCR = 1;
  }
  return;
}

/******************************************************************************
** Function name:		disable_timer
**
** Descriptions:		Disable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void disable_timer32(uint8_t timer_num)
{
  if ( timer_num == 0 )
  {
    LPC_TMR32B0->TCR = 0;
  }
  else
  {
    LPC_TMR32B1->TCR = 0;
  }
  return;
}

/******************************************************************************
** Function name:		reset_timer
**
** Descriptions:		Reset timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void reset_timer32(uint8_t timer_num)
{
  uint32_t regVal;

  if ( timer_num == 0 )
  {
    regVal = LPC_TMR32B0->TCR;
    regVal |= 0x02;
    LPC_TMR32B0->TCR = regVal;
  }
  else
  {
    regVal = LPC_TMR32B1->TCR;
    regVal |= 0x02;
    LPC_TMR32B1->TCR = regVal;
  }
  return;
}

/******************************************************************************
** Function name:		init_timer
**
** Descriptions:		Initialize timer, set timer interval, reset timer,
**						install timer interrupt handler
**
** parameters:			timer number and timer interval
** Returned value:		None
** 
******************************************************************************/
void init_timer32(uint8_t timer_num, uint32_t TimerInterval) 
{
  if ( timer_num == 0 )
  {
    /* Some of the I/O pins need to be carefully planned if
    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<9);
    LPC_IOCON->PIO1_5 &= ~0x07;	/*  Timer0_32 I/O config */
    LPC_IOCON->PIO1_5 |= 0x02;	/* Timer0_32 CAP0 */
    //LPC_IOCON->PIO1_6 &= ~0x07;
    //LPC_IOCON->PIO1_6 |= 0x02;	/* Timer0_32 MAT0 */
    //LPC_IOCON->PIO1_7 &= ~0x07;
    //LPC_IOCON->PIO1_7 |= 0x02;	/* Timer0_32 MAT1 */
    LPC_IOCON->PIO0_1 &= ~0x07;	
    LPC_IOCON->PIO0_1 |= 0x02;	/* Timer0_32 MAT2 */
#ifdef __JTAG_DISABLED
    LPC_IOCON->JTAG_TDI_PIO0_11 &= ~0x07;	
    LPC_IOCON->JTAG_TDI_PIO0_11 |= 0x03;	/* Timer0_32 MAT3 */
#endif
#if CONFIG_TIMER32_DEFAULT_TIMER32_0_IRQHANDLER==1
    timer32_0_counter = 0;
    timer32_0_capture = 0;
#endif //TIMER32_0_DEFAULT_HANDLER
    LPC_TMR32B0->PR  = KHZ_PRESCALE; /* set prescaler to get 1 K counts/sec */
    LPC_TMR32B0->MR0 = TimerInterval;
#if TIMER_MATCH
	LPC_TMR32B0->EMR &= ~(0xFF<<4);
	LPC_TMR32B0->EMR |= ((0x3<<4)|(0x3<<6)|(0x3<<8)|(0x3<<10));	/* MR0/1/2/3 Toggle */
#else
	/* Capture 0 on rising edge, interrupt enable. */
	LPC_TMR32B0->CCR = (0x1<<0)|(0x1<<2);
#endif
    LPC_TMR32B0->MCR = 3;			/* Interrupt and Reset on MR0 */

#if CONFIG_TIMER32_DEFAULT_TIMER32_0_IRQHANDLER==1
    /* Enable the TIMER0 Interrupt */
    NVIC_EnableIRQ(TIMER_32_0_IRQn);
#endif
  }
  else if ( timer_num == 1 )
  {
    /* Some of the I/O pins need to be clearfully planned if
    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<10);
#ifdef __JTAG_DISABLED
    LPC_IOCON->JTAG_TMS_PIO1_0  &= ~0x07;	/*  Timer1_32 I/O config */
    LPC_IOCON->JTAG_TMS_PIO1_0  |= 0x03;	/* Timer1_32 CAP0 */
    LPC_IOCON->JTAG_TDO_PIO1_1  &= ~0x07;	
    LPC_IOCON->JTAG_TDO_PIO1_1  |= 0x03;	/* Timer1_32 MAT0 */
    LPC_IOCON->JTAG_nTRST_PIO1_2 &= ~0x07;
    LPC_IOCON->JTAG_nTRST_PIO1_2 |= 0x03;	/* Timer1_32 MAT1 */
    LPC_IOCON->ARM_SWDIO_PIO1_3  &= ~0x07;
    LPC_IOCON->ARM_SWDIO_PIO1_3  |= 0x03;	/* Timer1_32 MAT2 */
#endif
    LPC_IOCON->PIO1_4 &= ~0x07;
    LPC_IOCON->PIO1_4 |= 0x02;		/* Timer0_32 MAT3 */

#if CONFIG_TIMER32_DEFAULT_TIMER32_1_IRQHANDLER==1
    timer32_1_counter = 0;
    timer32_1_capture = 0;
#endif //TIMER32_1_DEFAULT_HANDLER
    LPC_TMR32B1->PR  = KHZ_PRESCALE;  /* set prescaler to get 1 K counts/sec */
    LPC_TMR32B1->MR0 = TimerInterval;
#if TIMER_MATCH
	LPC_TMR32B1->EMR &= ~(0xFF<<4);
	LPC_TMR32B1->EMR |= ((0x3<<4)|(0x3<<6)|(0x3<<8)|(0x3<<10));	/* MR0/1/2 Toggle */
#else
	/* Capture 0 on rising edge, interrupt enable. */
	LPC_TMR32B1->CCR = (0x1<<0)|(0x1<<2);
#endif
    LPC_TMR32B1->MCR = 3;			/* Interrupt and Reset on MR0 */

#if CONFIG_TIMER32_DEFAULT_TIMER32_1_IRQHANDLER==1
    /* Enable the TIMER1 Interrupt */
    NVIC_EnableIRQ(TIMER_32_1_IRQn);
#endif
  }
  return;
}
/******************************************************************************
** Function name:		init_timer32PWM
**
** Descriptions:		Initialize timer as PWM
**
** parameters:			timer number, period and match enable:
**										match_enable[0] = PWM for MAT0 
**										match_enable[1] = PWM for MAT1
**										match_enable[2] = PWM for MAT2
**			
** Returned value:		None
** 
******************************************************************************/
void init_timer32PWM(uint8_t timer_num, uint32_t period, uint8_t match_enable)
{
	
	disable_timer32(timer_num);
	if (timer_num == 1)
	{
	    /* Some of the I/O pins need to be clearfully planned if
	    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
	    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<10);

		/* Setup the external match register */
		LPC_TMR32B1->EMR = (1<<EMC3)|(1<<EMC2)|(2<<EMC1)|(1<<EMC0)|(1<<3)|(match_enable);

		/* Setup the outputs */
		/* If match0 is enabled, set the output */
		if (match_enable & 0x01)
		{
		  	LPC_IOCON->R_PIO1_1  &= ~0x07;
  			LPC_IOCON->R_PIO1_1  |= 0x03;		/* Timer1_32 MAT0 */
		}
		/* If match1 is enabled, set the output */
		if (match_enable & 0x02)
		{
		  LPC_IOCON->R_PIO1_2 &= ~0x07;
		  LPC_IOCON->R_PIO1_2 |= 0x03;		/* Timer1_32 MAT1 */
		}
		/* If match2 is enabled, set the output */
		if (match_enable & 0x04)
		{
		  LPC_IOCON->SWDIO_PIO1_3   &= ~0x07;
		  LPC_IOCON->SWDIO_PIO1_3   |= 0x03;		/* Timer1_32 MAT2 */
		}
		/* If match3 is enabled, set the output */
		if (match_enable & 0x08)
		{
		  LPC_IOCON->PIO1_4           &= ~0x07;
		  LPC_IOCON->PIO1_4           |= 0x02;		/* Timer1_32 MAT3 */
		}

//#ifdef __JTAG_DISABLED
//	  PIO1_0_JTAG_TMS  &= ~0x07;	/*  Timer1_32 I/O config */
//	  PIO1_0_JTAG_TMS  |= 0x03;		/* Timer1_32 CAP0 */
//#endif

		/* Enable the selected PWMs and enable Match3 */
		LPC_TMR32B1->PWMC = (1<<3)|(match_enable);
		LPC_TMR32B1->PR = KHZ_PRESCALE/3000;  /* set prescaler to get 100 counts/sec */
 
		/* Setup the match registers */
		/* set the period value to a global variable */
		timer32_1_period = period;
		LPC_TMR32B1->MR3 = timer32_1_period;
		LPC_TMR32B1->MR0	= timer32_1_period/2;
		LPC_TMR32B1->MR1	= timer32_1_period/2;
		LPC_TMR32B1->MR2	= timer32_1_period/2;
		
		/* */
    	LPC_TMR32B1->MCR = 1<<10;				/* Reset on MR3 */
	}
	else
	{
	    /* Some of the I/O pins need to be clearfully planned if
	    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
	    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<9);

		/* Setup the external match register */
		LPC_TMR32B0->EMR = (1<<EMC3)|(2<<EMC2)|(1<<EMC1)|(1<<EMC0)|(1<<3)|(match_enable);
 
		/* Setup the outputs */
		/* If match0 is enabled, set the output */
		if (match_enable & 0x01)
		{
//	 		LPC_IOCON->PIO1_6           &= ~0x07;
//		  	LPC_IOCON->PIO1_6           |= 0x02;		/* Timer0_32 MAT0 */
		}
		/* If match1 is enabled, set the output */
		if (match_enable & 0x02)
		{
			LPC_IOCON-> PIO1_7           &= ~0x07;
		  	LPC_IOCON->PIO1_7           |= 0x02;		/* Timer0_32 MAT1 */
		}
		/* If match2 is enabled, set the output */
		if (match_enable & 0x04)
		{
		  LPC_IOCON->PIO0_1           &= ~0x07;	
		  LPC_IOCON->PIO0_1           |= 0x02;		/* Timer0_32 MAT2 */
		}
		/* If match3 is enabled, set the output */
		if (match_enable & 0x08)
		{
		  LPC_IOCON->R_PIO0_11 &= ~0x07;
		  LPC_IOCON->R_PIO0_11 |= 0x03;		/* Timer0_32 MAT3 */
		}

		/* Enable the selected PWMs and enable Match3 */
		LPC_TMR32B0->PWMC = (1<<3)|(match_enable);

		/* Setup the match registers */
		/* set the period value to a global variable */
		timer32_0_period = period;
		LPC_TMR32B0->MR3 = timer32_0_period;
		LPC_TMR32B0->MR0	= timer32_0_period;	///2;
		LPC_TMR32B0->MR1	= timer32_0_period/2;
		LPC_TMR32B0->MR2	= timer32_0_period/2;

    	LPC_TMR32B0->MCR = 1<<10;				/* Reset on MR3 */
	}


}
/******************************************************************************
** Function name:		pwm32_setMatch
**
** Descriptions:		Set the pwm32 match values
**
** parameters:			timer number, match numner and the value
**
** Returned value:		None
** 
******************************************************************************/
void setMatch_timer32PWM (uint8_t timer_num, uint8_t match_nr, uint32_t value)
{
	if (timer_num)
	{
		switch (match_nr)
		{
			case 0:
				LPC_TMR32B1->MR0 = value;
				break;
			case 1: 
				LPC_TMR32B1->MR1 = value;
				break;
			case 2:
				LPC_TMR32B1->MR2 = value;
				break;
			case 3: 
				LPC_TMR32B1->MR3 = value;
				break;
			default:
				break;
		}	

	}
	else 
	{
		switch (match_nr)
		{
			case 0:
				LPC_TMR32B0->MR0 = value;
				break;
			case 1: 
				LPC_TMR32B0->MR1 = value;
				break;
			case 2:
				LPC_TMR32B0->MR2 = value;
				break;
			case 3: 
				LPC_TMR32B0->MR3 = value;
				break;
			default:
				break;
		}	
	}

}
#endif

/******************************************************************************
**                            End Of File
******************************************************************************/ 
\end{verbatim}

\subsubsection{timer32.h}

\begin{verbatim}
 /****************************************************************************
 *   $Id:: timer32.h 4785 2010-09-03 22:39:27Z nxp21346                     $
 *   Project: NXP LPC11xx software example
 *
 *   Description:
 *     This file contains definition and prototype for 32-bit timer 
 *     configuration.
 *
 ****************************************************************************
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * products. This software is supplied "AS IS" without any warranties.
 * NXP Semiconductors assumes no responsibility or liability for the
 * use of the software, conveys no license or title under any patent,
 * copyright, or mask work right to the product. NXP Semiconductors
 * reserves the right to make changes in the software without
 * notification. NXP Semiconductors also make no representation or
 * warranty that such application will be suitable for the specified
 * use without further testing or modification.
****************************************************************************/
#ifndef __TIMER32_H 
#define __TIMER32_H
#if CONFIG_ENABLE_DRIVER_TIMER32==1

#define KHZ_PRESCALE    (SystemCoreClock/1000 -1)

/* The test is either MAT_OUT or CAP_IN. Default is MAT_OUT. */
#define TIMER_MATCH		0

#define EMC0	4
#define EMC1	6
#define EMC2	8
#define EMC3	10

#define MATCH0	(1<<0)
#define MATCH1	(1<<1)
#define MATCH2	(1<<2)
#define MATCH3	(1<<3)

#define TIME_INTERVAL	(SystemCoreClock/100 - 1)
/* depending on the SystemFrequency and SystemAHBFrequency setting, 
if SystemFrequency = 60Mhz, SystemAHBFrequency = 1/4 SystemAHBFrequency, 
10mSec = 150.000-1 counts */

void delay32Ms(uint8_t timer_num, uint32_t delayInMs);

#if CONFIG_TIMER32_DEFAULT_TIMER32_0_IRQHANDLER==1
extern volatile uint32_t timer32_0_counter;
#endif

#if CONFIG_TIMER32_DEFAULT_TIMER32_1_IRQHANDLER==1
extern volatile uint32_t timer32_1_counter;
#endif

void enable_timer32(uint8_t timer_num);
void disable_timer32(uint8_t timer_num);
void reset_timer32(uint8_t timer_num);
void init_timer32(uint8_t timer_num, uint32_t timerInterval);
void init_timer32PWM(uint8_t timer_num, uint32_t period, uint8_t match_enable);
void setMatch_timer32PWM (uint8_t timer_num, uint8_t match_nr, uint32_t value);

#endif
#endif /* end __TIMER32_H */
/*****************************************************************************
**                            End Of File
******************************************************************************/
\end{verbatim}

\subsubsection{type.h}

\begin{verbatim}
 /*****************************************************************************
 *   type.h:  Type definition Header file for NXP Family 
 *   Microprocessors
 *
 *   Copyright(C) 2006, NXP Semiconductor
 *   All rights reserved.
 *
 *   History
 *   2009.04.01  ver 1.00    Preliminary version, first Release
 *
******************************************************************************/
#ifndef __TYPE_H__
#define __TYPE_H__

// CodeRed - ifdef for GNU added to avoid potential clash with stdint.h
#if defined   (  __GNUC__  )
#include <stdint.h>
#else

/* exact-width signed integer types */
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       __int64 int64_t;

 /* exact-width unsigned integer types */
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       __int64 uint64_t;

#endif // __GNUC__ 

#ifndef NULL
#define NULL    ((void *)0)
#endif

#ifndef FALSE
#define FALSE   (0)
#endif

#ifndef TRUE
#define TRUE    (1)
#endif

#endif  /* __TYPE_H__ */
\end{verbatim}

\subsubsection{uart.c}

\begin{verbatim}
 /*****************************************************************************
 *   uart.c:  UART API file for NXP LPC11xx Family Microprocessors
 *
 *   Copyright(C) 2008, NXP Semiconductor
 *   All rights reserved.
 *
 *   History
 *   2009.12.07  ver 1.00    Preliminary version, first Release
 *
******************************************************************************/
#include "driver_config.h"
#if CONFIG_ENABLE_DRIVER_UART==1
#include "uart.h"

volatile uint32_t UARTStatus;
volatile uint8_t  UARTTxEmpty = 1;
volatile uint8_t  UARTBuffer[UART_BUFSIZE];
volatile uint32_t UARTCount = 0;

#if CONFIG_UART_DEFAULT_UART_IRQHANDLER==1
/*****************************************************************************
** Function name:		UART_IRQHandler
**
** Descriptions:		UART interrupt handler
**
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void UART_IRQHandler(void)
{
  uint8_t IIRValue, LSRValue;
  uint8_t Dummy = Dummy;

  IIRValue = LPC_UART->IIR;
    
  IIRValue >>= 1;			/* skip pending bit in IIR */
  IIRValue &= 0x07;			/* check bit 1~3, interrupt identification */
  if (IIRValue == IIR_RLS)		/* Receive Line Status */
  {
    LSRValue = LPC_UART->LSR;
    /* Receive Line Status */
    if (LSRValue & (LSR_OE | LSR_PE | LSR_FE | LSR_RXFE | LSR_BI))
    {
      /* There are errors or break interrupt */
      /* Read LSR will clear the interrupt */
      UARTStatus = LSRValue;
      Dummy = LPC_UART->RBR;	/* Dummy read on RX to clear 
								interrupt, then bail out */
      return;
    }
    if (LSRValue & LSR_RDR)	/* Receive Data Ready */			
    {
      /* If no error on RLS, normal ready, save into the data buffer. */
      /* Note: read RBR will clear the interrupt */
      UARTBuffer[UARTCount++] = LPC_UART->RBR;
      if (UARTCount == UART_BUFSIZE)
      {
        UARTCount = 0;		/* buffer overflow */
      }	
    }
  }
  else if (IIRValue == IIR_RDA)	/* Receive Data Available */
  {
    /* Receive Data Available */
    UARTBuffer[UARTCount++] = LPC_UART->RBR;
    if (UARTCount == UART_BUFSIZE)
    {
      UARTCount = 0;		/* buffer overflow */
    }
  }
  else if (IIRValue == IIR_CTI)	/* Character timeout indicator */
  {
    /* Character Time-out indicator */
    UARTStatus |= 0x100;		/* Bit 9 as the CTI error */
  }
  else if (IIRValue == IIR_THRE)	/* THRE, transmit holding register empty */
  {
    /* THRE interrupt */
    LSRValue = LPC_UART->LSR;		/* Check status in the LSR to see if
								valid data in U0THR or not */
    if (LSRValue & LSR_THRE)
    {
      UARTTxEmpty = 1;
    }
    else
    {
      UARTTxEmpty = 0;
    }
  }
  return;
}
#endif

/*****************************************************************************
** Function name:		ModemInit
**
** Descriptions:		Initialize UART0 port as modem, setup pin select.
**
** parameters:			None
** Returned value:		None
** 
*****************************************************************************/
void ModemInit( void )
{
  LPC_IOCON->PIO2_0 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO2_0 |= 0x01;     /* UART DTR */
  LPC_IOCON->PIO0_7 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO0_7 |= 0x01;     /* UART CTS */
  LPC_IOCON->PIO1_5 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO1_5 |= 0x01;     /* UART RTS */
#if 1 
  LPC_IOCON->DSR_LOC	= 0;
  LPC_IOCON->PIO2_1 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO2_1 |= 0x01;     /* UART DSR */

  LPC_IOCON->DCD_LOC	= 0;
  LPC_IOCON->PIO2_2 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO2_2 |= 0x01;     /* UART DCD */

  LPC_IOCON->RI_LOC	= 0;
  LPC_IOCON->PIO2_3 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO2_3 |= 0x01;     /* UART RI */

#else
  LPC_IOCON->DSR_LOC = 1;
  LPC_IOCON->PIO3_1 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO3_1 |= 0x01;     /* UART DSR */

  LPC_IOCON->DCD_LOC = 1;
  LPC_IOCON->PIO3_2 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO3_2 |= 0x01;     /* UART DCD */

  LPC_IOCON->RI_LOC = 1;
  LPC_IOCON->PIO3_3 &= ~0x07;    /* UART I/O config */
  LPC_IOCON->PIO3_3 |= 0x01;     /* UART RI */
#endif
  LPC_UART->MCR = 0xC0;          /* Enable Auto RTS and Auto CTS. */			
  return;
}

/*****************************************************************************
** Function name:		UARTInit
**
** Descriptions:		Initialize UART0 port, setup pin select,
**				clock, parity, stop bits, FIFO, etc.
**
** parameters:			UART baudrate
** Returned value:		None
** 
*****************************************************************************/
void UARTInit(uint32_t baudrate)
{
  uint32_t Fdiv;
  uint32_t regVal;

  UARTTxEmpty = 1;
  UARTCount = 0;
  
  NVIC_DisableIRQ(UART_IRQn);

  LPC_IOCON->PIO1_6 &= ~0x07;    /*  UART I/O config */
  LPC_IOCON->PIO1_6 |= 0x01;     /* UART RXD */
  LPC_IOCON->PIO1_7 &= ~0x07;	
  LPC_IOCON->PIO1_7 |= 0x01;     /* UART TXD */
  /* Enable UART clock */
  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<12);
  LPC_SYSCON->UARTCLKDIV = 0x1;     /* divided by 1 */

  LPC_UART->LCR = 0x83;             /* 8 bits, no Parity, 1 Stop bit */
  regVal = LPC_SYSCON->UARTCLKDIV;

  Fdiv = (((SystemCoreClock*LPC_SYSCON->SYSAHBCLKDIV)/regVal)/16)/baudrate ;	/*baud rate */

  LPC_UART->DLM = Fdiv / 256;							
  LPC_UART->DLL = Fdiv % 256;
  LPC_UART->LCR = 0x03;		/* DLAB = 0 */
  LPC_UART->FCR = 0x07;		/* Enable and reset TX and RX FIFO. */

  /* Read to clear the line status. */
  regVal = LPC_UART->LSR;

  /* Ensure a clean start, no data in either TX or RX FIFO. */
// CodeRed - added parentheses around comparison in operand of &
  while (( LPC_UART->LSR & (LSR_THRE|LSR_TEMT)) != (LSR_THRE|LSR_TEMT) );
  while ( LPC_UART->LSR & LSR_RDR )
  {
	regVal = LPC_UART->RBR;	/* Dump data from RX FIFO */
  }
 
  /* Enable the UART Interrupt */
  NVIC_EnableIRQ(UART_IRQn);

#if CONFIG_UART_ENABLE_INTERRUPT==1
#if CONFIG_UART_ENABLE_TX_INTERRUPT==1
  LPC_UART->IER = IER_RBR | IER_THRE | IER_RLS;	/* Enable UART interrupt */
#else
  LPC_UART->IER = IER_RBR | IER_RLS;	/* Enable UART interrupt */
#endif
#endif
  return;
}

/*****************************************************************************
** Function name:		UARTSend
**
** Descriptions:		Send a block of data to the UART 0 port based
**				on the data length
**
** parameters:		buffer pointer, and data length
** Returned value:	None
** 
*****************************************************************************/
void UARTSend(uint8_t *BufferPtr, uint32_t Length)
{
  
  while ( Length != 0 )
  {
	  /* THRE status, contain valid data */
#if CONFIG_UART_ENABLE_TX_INTERRUPT==1
	  /* Below flag is set inside the interrupt handler when THRE occurs. */
      while ( !(UARTTxEmpty & 0x01) );
	  LPC_UART->THR = *BufferPtr;
      UARTTxEmpty = 0;	/* not empty in the THR until it shifts out */
#else
	  while ( !(LPC_UART->LSR & LSR_THRE) );
	  LPC_UART->THR = *BufferPtr;
#endif
      BufferPtr++;
      Length--;
  }
  return;
}
#endif

/******************************************************************************
**                            End Of File
******************************************************************************/
\end{verbatim}

\subsubsection{uart.h}

\begin{verbatim}
 /*****************************************************************************
 *   uart.h:  Header file for NXP LPC1xxx Family Microprocessors
 *
 *   Copyright(C) 2008, NXP Semiconductor
 *   All rights reserved.
 *
 *   History
 *   2009.12.07  ver 1.00    Preliminary version, first Release
 *
******************************************************************************/
#ifndef __UART_H 
#define __UART_H

#if CONFIG_ENABLE_DRIVER_UART==1

#define RS485_ENABLED		0
#define TX_INTERRUPT		0		/* 0 if TX uses polling, 1 interrupt driven. */
#define MODEM_TEST			0

#define IER_RBR		0x01
#define IER_THRE	0x02
#define IER_RLS		0x04

#define IIR_PEND	0x01
#define IIR_RLS		0x03
#define IIR_RDA		0x02
#define IIR_CTI		0x06
#define IIR_THRE	0x01

#define LSR_RDR		0x01
#define LSR_OE		0x02
#define LSR_PE		0x04
#define LSR_FE		0x08
#define LSR_BI		0x10
#define LSR_THRE	0x20
#define LSR_TEMT	0x40
#define LSR_RXFE	0x80

#define UART_BUFSIZE		0x40

/* RS485 mode definition. */
#define RS485_NMMEN		(0x1<<0)
#define RS485_RXDIS		(0x1<<1)
#define RS485_AADEN		(0x1<<2)
#define RS485_SEL		(0x1<<3)
#define RS485_DCTRL		(0x1<<4)
#define RS485_OINV		(0x1<<5)

void ModemInit( void );
void UARTInit(uint32_t Baudrate);
void UART_IRQHandler(void);
void UARTSend(uint8_t *BufferPtr, uint32_t Length);

#endif
#endif /* end __UART_H */
/*****************************************************************************
**                            End Of File
******************************************************************************/
\end{verbatim}

\subsection{Src}

Escrever pequeno texto a respeito do que é o Src

Seguem abaixo os arquivos utilizados:

\subsubsection{ADXL345.c}

\begin{verbatim}
/*
	ADXL345 Library
	
	This libary contains functions to interact with the ADXL345 Triple Axis Digital Accelerometer from Analog Devices written for the ATmega168
	
	created 20 Aug 2009
	by Ryan Owens
	http://www.sparkfun.com
	
 
*/
#include "ADXL345.h"


#define GLOBALOBJECT

//Initialize the I2C communication and put the accelerometer in Measure mode
void Accel_Init()
{

	//Put the accelerometer in MEASURE mode
	I2C_write(ADXL_ADDR, POWER_CTL, MEASURE);
	
	//Set the Range to +/- 4G
	I2C_write(ADXL_ADDR, DATA_FORMAT, RANGE_0);
	
	//default ADXL345 rate is 100 Hz. Perfect!
}

//Read a register value from the ADXL345
//pre: register_addr is the register address to Accel_Read
//	   value is a pointer to an integer
//post: value contains the value of the register that was Accel_Read
//returns: 1-Success
//		   TWSR-Failure (Check out twi.h for TWSR error codes)
//usage: status = accelerometer.I2C_read(ADXL_ADDR, DEVID, &value); //value is created as an 'int' in main.cpp

//Reads the x,y and z registers and stores the contents into x,y and z variables
//returns 1
//usage: accelerometer.update();
//Note: update must be called before using the getX, getY or getZ functions in order
//      to obtain the most recent values from the accelerometer
void Accel_Update(accel_data_t accel_data)
{
	char aux0=0,aux1=0;

	I2C_read(ADXL_ADDR, DATAX0, &aux0);
	I2C_read(ADXL_ADDR, DATAX1, &aux1);
	accel_data->x = (aux1<<8)|aux0;
	accel_data->x_ant = accel_data->x;
	
	I2C_read(ADXL_ADDR, DATAY0, &aux0);
	I2C_read(ADXL_ADDR, DATAY1, &aux1);
	accel_data->y = (aux1<<8)|aux0;
	accel_data->y_ant = accel_data->y;

	I2C_read(ADXL_ADDR, DATAZ0, &aux0);
	I2C_read(ADXL_ADDR, DATAZ1, &aux1);
	accel_data->z = (aux1<<8)|aux0;
	accel_data->z_ant = accel_data->z;
}

/*
get functions return the g value of the specified axis
The conversion is based on a +/-4G range.
If range is changed, make sure to update the scaling in the get functions
usage: printf("Xg = %1.3fg", (double)accelerometer.getX()
*/
/* TODO: remover
void Accel_GetX(void)
{
	Accel_Xr = (float)Accel_X*0.0078;	
}

void Accel_GetY(void)
{
	Accel_Yr = (float)Accel_Y*0.0078;
}

void Accel_GetZ(void)
{
	Accel_Zr = (float)Accel_Z*0.0078;
}
*/\end{verbatim}

\subsubsection{ADXL345.h}

\begin{verbatim}
#ifndef ADXL345_h
#define ADXL345_h

#include <stdint.h>
#include "driver_config.h"
#include "type.h"
#include "i2c_driver.h"
#include "I2C.h"

typedef struct accel_data_t {
	int16_t x, y, z;  // Sinal tridimensional do acelerômetro
	int16_t x_ant, y_ant, z_ant;  // Sinal do passo anterior do acelerômetro
}* accel_data_t;

int Accel_X;
int Accel_Y;
int Accel_Z;
/* TODO: remover
float Accel_Xr;
float Accel_Yr;
float Accel_Zr;
*/

void Accel_Init();
void Accel_Update(accel_data_t accel_data);
/* TODO: remover
void Accel_GetX();
void Accel_GetY();
void Accel_GetZ();
*/

//**********************************************************
//
//                  Pin Definitions
//
//**********************************************************
#define ADXL_ADDR	0xA6

//ADXL Register Map
#define	DEVID			0x00	//Device ID Register
#define THRESH_TAP		0x1D	//Tap Threshold
#define	OFSX			0x1E	//X-axis offset
#define	OFSY			0x1F	//Y-axis offset
#define	OFSZ			0x20	//Z-axis offset
#define	DUR				0x21	//Tap Duration
#define	Latent			0x22	//Tap latency
#define	Window			0x23	//Tap window
#define	THRESH_ACT		0x24	//Activity Threshold
#define	THRESH_INACT	0x25	//Inactivity Threshold
#define	TIME_INACT		0x26	//Inactivity Time
#define	ACT_INACT_CTL	0x27	//Axis enable control for activity and inactivity detection
#define	THRESH_FF		0x28	//free-fall threshold
#define	TIME_FF			0x29	//Free-Fall Time
#define	TAP_AXES		0x2A	//Axis control for tap/double tap
#define ACT_TAP_STATUS	0x2B	//Source of tap/double tap
#define	BW_RATE			0x2C	//Data rate and power mode control
#define POWER_CTL		0x2D	//Power Control Register
#define	INT_ENABLE		0x2E	//Interrupt Enable Control
#define	INT_MAP			0x2F	//Interrupt Mapping Control
#define	INT_SOURCE		0x30	//Source of interrupts
#define	DATA_FORMAT		0x31	//Data format control
#define DATAX0			0x32	//X-Axis Data 0
#define DATAX1			0x33	//X-Axis Data 1
#define DATAY0			0x34	//Y-Axis Data 0
#define DATAY1			0x35	//Y-Axis Data 1
#define DATAZ0			0x36	//Z-Axis Data 0
#define DATAZ1			0x37	//Z-Axis Data 1
#define	FIFO_CTL		0x38	//FIFO control
#define	FIFO_STATUS		0x39	//FIFO status

//Power Control Register Bits
#define WU_0		(1<<0)	//Wake Up Mode - Bit 0
#define	WU_1		(1<<1)	//Wake Up mode - Bit 1
#define SLEEP		(1<<2)	//Sleep Mode
#define	MEASURE		(1<<3)	//Measurement Mode
#define AUTO_SLP	(1<<4)	//Auto Sleep Mode bit
#define LINK		(1<<5)	//Link bit

//Interrupt Enable/Interrupt Map/Interrupt Source Register Bits
#define	OVERRUN		(1<<0)
#define	WATERMARK	(1<<1)
#define FREE_FALL	(1<<2)
#define	INACTIVITY	(1<<3)
#define	ACTIVITY	(1<<4)
#define DOUBLE_TAP	(1<<5)
#define	SINGLE_TAP	(1<<6)
#define	DATA_READY	(1<<7)

//Data Format Bits
#define RANGE_0		(1<<0)
#define	RANGE_1		(1<<1)
#define JUSTIFY		(1<<2)
#define	FULL_RES	(1<<3)

#define	INT_INVERT	(1<<5)
#define	SPI			(1<<6)
#define	SELF_TEST	(1<<7)

#endif 
\end{verbatim}

\subsubsection{cr\_startup\_lpc11.c}

\begin{verbatim}
//*****************************************************************************
//   +--+       
//   | ++----+   
//   +-++    |  
//     |     |  
//   +-+--+  |   
//   | +--+--+  
//   +----+    Copyright (c) 2009-10 Code Red Technologies Ltd.
//
// Microcontroller Startup code for use with Red Suite
//
// Version : 101130
//
// Software License Agreement
// 
// The software is owned by Code Red Technologies and/or its suppliers, and is 
// protected under applicable copyright laws.  All rights are reserved.  Any 
// use in violation of the foregoing restrictions may subject the user to criminal 
// sanctions under applicable laws, as well as to civil liability for the breach 
// of the terms and conditions of this license.
// 
// THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
// USE OF THIS SOFTWARE FOR COMMERCIAL DEVELOPMENT AND/OR EDUCATION IS SUBJECT
// TO A CURRENT END USER LICENSE AGREEMENT (COMMERCIAL OR EDUCATIONAL) WITH
// CODE RED TECHNOLOGIES LTD. 
//
//*****************************************************************************
#if defined (__cplusplus)
#ifdef __REDLIB__
#error Redlib does not support C++
#else
//*****************************************************************************
//
// The entry point for the C++ library startup
//
//*****************************************************************************
extern "C" {
	extern void __libc_init_array(void);
}
#endif
#endif

#define WEAK __attribute__ ((weak))
#define ALIAS(f) __attribute__ ((weak, alias (#f)))

// Code Red - if CMSIS is being used, then SystemInit() routine
// will be called by startup code rather than in application's main()
#if defined (__USE_CMSIS)
#include "system_LPC11xx.h"
#endif

//*****************************************************************************
#if defined (__cplusplus)
extern "C" {
#endif

//*****************************************************************************
//
// Forward declaration of the default handlers. These are aliased.
// When the application defines a handler (with the same name), this will 
// automatically take precedence over these weak definitions
//
//*****************************************************************************
     void ResetISR(void);
WEAK void NMI_Handler(void);
WEAK void HardFault_Handler(void);
WEAK void SVCall_Handler(void);
WEAK void PendSV_Handler(void);
WEAK void SysTick_Handler(void);
WEAK void IntDefaultHandler(void);
//*****************************************************************************
//
// Forward declaration of the specific IRQ handlers. These are aliased
// to the IntDefaultHandler, which is a 'forever' loop. When the application
// defines a handler (with the same name), this will automatically take
// precedence over these weak definitions
//
//*****************************************************************************

void CAN_IRQHandler (void) ALIAS(IntDefaultHandler);
void SSP1_IRQHandler (void) ALIAS(IntDefaultHandler);
void I2C_IRQHandler (void) ALIAS(IntDefaultHandler);
void TIMER16_0_IRQHandler (void) ALIAS(IntDefaultHandler);
void TIMER16_1_IRQHandler (void) ALIAS(IntDefaultHandler);
void TIMER32_0_IRQHandler (void) ALIAS(IntDefaultHandler);
void TIMER32_1_IRQHandler (void) ALIAS(IntDefaultHandler);
void SSP0_IRQHandler (void) ALIAS(IntDefaultHandler);
void UART_IRQHandler (void) ALIAS(IntDefaultHandler);
void ADC_IRQHandler (void) ALIAS(IntDefaultHandler);
void WDT_IRQHandler (void) ALIAS(IntDefaultHandler);
void BOD_IRQHandler (void) ALIAS(IntDefaultHandler);
void PIOINT3_IRQHandler (void) ALIAS(IntDefaultHandler);
void PIOINT2_IRQHandler (void) ALIAS(IntDefaultHandler);
void PIOINT1_IRQHandler (void) ALIAS(IntDefaultHandler);
void PIOINT0_IRQHandler (void) ALIAS(IntDefaultHandler);
void WAKEUP_IRQHandler  (void) ALIAS(IntDefaultHandler);

//*****************************************************************************
//
// The entry point for the application.
// __main() is the entry point for redlib based applications
// main() is the entry point for newlib based applications
//
//*****************************************************************************
//
// The entry point for the application.
// __main() is the entry point for Redlib based applications
// main() is the entry point for Newlib based applications
//
//*****************************************************************************
#if defined (__REDLIB__)
extern void __main(void);
#endif
extern int main(void);
//*****************************************************************************
//
// External declaration for the pointer to the stack top from the Linker Script
//
//*****************************************************************************
extern void _vStackTop(void);

//*****************************************************************************
#if defined (__cplusplus)
} // extern "C"
#endif
//*****************************************************************************
//
// The vector table.  Note that the proper constructs must be placed on this to
// ensure that it ends up at physical address 0x0000.0000.
//
//*****************************************************************************
extern void (* const g_pfnVectors[])(void);
__attribute__ ((section(".isr_vector")))
void (* const g_pfnVectors[])(void) = {
    &_vStackTop,		    				// The initial stack pointer
    ResetISR,                               // The reset handler
    NMI_Handler,                            // The NMI handler
    HardFault_Handler,                      // The hard fault handler
    0,                      				// Reserved
    0,                      				// Reserved
    0,                      				// Reserved
    0,                                      // Reserved
    0,                                      // Reserved
    0,                                      // Reserved
    0,                                      // Reserved
    SVCall_Handler,                      	// SVCall handler
    0,                      				// Reserved
    0,                                      // Reserved
    PendSV_Handler,                      	// The PendSV handler
    SysTick_Handler,                      	// The SysTick handler

    // Wakeup sources for the I/O pins:
    //   PIO0 (0:11)
    //   PIO1 (0)
    WAKEUP_IRQHandler,                      // PIO0_0  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_1  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_2  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_3  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_4  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_5  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_6  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_7  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_8  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_9  Wakeup
    WAKEUP_IRQHandler,                      // PIO0_10 Wakeup
    WAKEUP_IRQHandler,                      // PIO0_11 Wakeup
    WAKEUP_IRQHandler,                      // PIO1_0  Wakeup
    
    CAN_IRQHandler,							// C_CAN Interrupt
    SSP1_IRQHandler, 						// SPI/SSP1 Interrupt
    I2C_IRQHandler,                      	// I2C0
    TIMER16_0_IRQHandler,                   // CT16B0 (16-bit Timer 0)
    TIMER16_1_IRQHandler,                   // CT16B1 (16-bit Timer 1)
    TIMER32_0_IRQHandler,                   // CT32B0 (32-bit Timer 0)
    TIMER32_1_IRQHandler,                   // CT32B1 (32-bit Timer 1)
    SSP0_IRQHandler,                      	// SPI/SSP0 Interrupt
    UART_IRQHandler,                      	// UART0

    0, 				                     	// Reserved
    0,                      				// Reserved

    ADC_IRQHandler,                      	// ADC   (A/D Converter)
    WDT_IRQHandler,                      	// WDT   (Watchdog Timer)
    BOD_IRQHandler,                      	// BOD   (Brownout Detect)
    0,                      				// Reserved
    PIOINT3_IRQHandler,                     // PIO INT3
    PIOINT2_IRQHandler,                     // PIO INT2
    PIOINT1_IRQHandler,                     // PIO INT1
    PIOINT0_IRQHandler,                     // PIO INT0
};

//*****************************************************************************
// Functions to carry out the initialization of RW and BSS data sections. These
// are written as separate functions rather than being inlined within the
// ResetISR() function in order to cope with MCUs with multiple banks of
// memory.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
	unsigned int *pulDest = (unsigned int*) start;
	unsigned int *pulSrc = (unsigned int*) romstart;
	unsigned int loop;
	for (loop = 0; loop < len; loop = loop + 4)
		*pulDest++ = *pulSrc++;
}

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
	unsigned int *pulDest = (unsigned int*) start;
	unsigned int loop;
	for (loop = 0; loop < len; loop = loop + 4)
		*pulDest++ = 0;
}

#ifndef USE_OLD_STYLE_DATA_BSS_INIT
//*****************************************************************************
// The following symbols are constructs generated by the linker, indicating
// the location of various points in the "Global Section Table". This table is
// created by the linker via the Code Red managed linker script mechanism. It
// contains the load address, execution address and length of each RW data
// section and the execution and length of each BSS (zero initialized) section.
//*****************************************************************************
extern unsigned int __data_section_table;
extern unsigned int __data_section_table_end;
extern unsigned int __bss_section_table;
extern unsigned int __bss_section_table_end;
#else
//*****************************************************************************
// The following symbols are constructs generated by the linker, indicating
// the load address, execution address and length of the RW data section and
// the execution and length of the BSS (zero initialized) section.
// Note that these symbols are not normally used by the managed linker script
// mechanism in Red Suite/LPCXpresso 3.6 (Windows) and LPCXpresso 3.8 (Linux).
// They are provide here simply so this startup code can be used with earlier
// versions of Red Suite which do not support the more advanced managed linker
// script mechanism introduced in the above version. To enable their use,
// define "USE_OLD_STYLE_DATA_BSS_INIT".
//*****************************************************************************
extern unsigned int _etext;
extern unsigned int _data;
extern unsigned int _edata;
extern unsigned int _bss;
extern unsigned int _ebss;
#endif


//*****************************************************************************
// Reset entry point for your code.
// Sets up a simple runtime environment and initializes the C/C++
// library.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void
ResetISR(void) {

#ifndef USE_OLD_STYLE_DATA_BSS_INIT
    //
    // Copy the data sections from flash to SRAM.
    //
	unsigned int LoadAddr, ExeAddr, SectionLen;
	unsigned int *SectionTableAddr;

	// Load base address of Global Section Table
	SectionTableAddr = &__data_section_table;

    // Copy the data sections from flash to SRAM.
	while (SectionTableAddr < &__data_section_table_end) {
		LoadAddr = *SectionTableAddr++;
		ExeAddr = *SectionTableAddr++;
		SectionLen = *SectionTableAddr++;
		data_init(LoadAddr, ExeAddr, SectionLen);
	}
	// At this point, SectionTableAddr = &__bss_section_table;
	// Zero fill the bss segment
	while (SectionTableAddr < &__bss_section_table_end) {
		ExeAddr = *SectionTableAddr++;
		SectionLen = *SectionTableAddr++;
		bss_init(ExeAddr, SectionLen);
	}
#else
	// Use Old Style Data and BSS section initialization.
	// This will only initialize a single RAM bank.
	unsigned int * LoadAddr, *ExeAddr, *EndAddr, SectionLen;

    // Copy the data segment from flash to SRAM.
	LoadAddr = &_etext;
	ExeAddr = &_data;
	EndAddr = &_edata;
	SectionLen = (void*)EndAddr - (void*)ExeAddr;
	data_init((unsigned int)LoadAddr, (unsigned int)ExeAddr, SectionLen);
	// Zero fill the bss segment
	ExeAddr = &_bss;
	EndAddr = &_ebss;
	SectionLen = (void*)EndAddr - (void*)ExeAddr;
	bss_init ((unsigned int)ExeAddr, SectionLen);
#endif

#ifdef __USE_CMSIS
	SystemInit();
#endif

#if defined (__cplusplus)
	//
	// Call C++ library initialisation
	//
	__libc_init_array();
#endif

#if defined (__REDLIB__)
	// Call the Redlib library, which in turn calls main()
	__main() ;
#else
	main();
#endif
	//
	// main() shouldn't return, but if it does, we'll just enter an infinite loop
	//
	while (1) {
		;
	}
}

//*****************************************************************************
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void)
{
    while(1)
    {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void)
{
    while(1)
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SVCall_Handler(void)
{
    while(1)
    {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void)
{
    while(1)
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void)
{
    while(1)
    {
    }
}

//*****************************************************************************
//
// Processor ends up here if an unexpected interrupt occurs or a specific
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void)
{
    while(1)
    {
    }
}
 
\end{verbatim}

\subsubsection{I2C.c}

\begin{verbatim}
/*
 * I2C.c
 *
 *  Created on: 25/10/2011
 *      Author: traysh
 */

#include "I2C.h"

extern volatile uint32_t I2CCount;
extern volatile uint32_t I2CMasterState;

void I2C_read(char sla_addr, char reg_addr, char * value) {

	/* Write SLA(W), address, SLA(R), and read one byte back. */
	I2CWriteLength = 2;
	I2CReadLength = 1;
	I2CMasterBuffer[0] = sla_addr;	// Slave I2C address
	I2CMasterBuffer[1] = reg_addr;	// Register address
	I2CMasterBuffer[2] = sla_addr | RD_BIT;
	I2CEngine();

	*value = I2CSlaveBuffer[0];
	
}

void I2C_write(char sla_addr, char reg_addr, char value) {

	I2CWriteLength = 3;
	I2CReadLength = 0;
	I2CMasterBuffer[0] = sla_addr;	// Slave I2C address
	I2CMasterBuffer[1] = reg_addr;	// Register address
	I2CMasterBuffer[2] = value;		// Data

	I2CEngine();

} 
\end{verbatim}

\subsubsection{I2C.h}

\begin{verbatim}
/*
 * I2C.h
 *
 *  Created on: 25/10/2011
 *      Author: traysh
 */

#ifndef I2C_H_
#define I2C_H_

#include "driver_config.h"
#include "type.h"
#include "i2c_driver.h"

extern volatile uint8_t I2CMasterBuffer[I2C_BUFSIZE];
extern volatile uint8_t I2CSlaveBuffer[I2C_BUFSIZE];
extern volatile uint32_t I2CReadLength, I2CWriteLength;
void I2C_read(char sla_addr, char reg_addr, char * value);
void I2C_write(char sla_addr, char reg_addr, char value);

#endif /* I2C_H_ */ 
\end{verbatim}

\subsubsection{ITG3200.c}

\begin{verbatim}
/*
	ITG3200 Library
	
	This libary contains functions to interact with the ITG3200 from Atmega168

	created 8/30/10
	by Ryan Owens
	http://www.sparkfun.com
 
*/

#include "ITG3200.h"
#include <stdlib.h>

#include "driver_config.h"
#include "target_config.h"

#include "type.h"
#include "I2C.h"

extern volatile uint32_t I2CCount;
extern volatile uint8_t I2CMasterBuffer[I2C_BUFSIZE];
extern volatile uint8_t I2CSlaveBuffer[I2C_BUFSIZE];
extern volatile uint32_t I2CMasterState;
extern volatile uint32_t I2CReadLength, I2CWriteLength;

//Initialize the i2c communication and set the gyro to full scale range and 100 Hz update rate
void Gyro_Init()
{

	//twiInit(80000);			//Init. SCL speed to 50 kHz
	
	//Set internal clock to 1kHz with 42Hz LPF and Full Scale to 3 for proper operation
	I2C_write(ITG_ADDR, DLPF_FS, DLPF_FS_SEL_0|DLPF_FS_SEL_1|DLPF_CFG_0);
	
	//Set sample rate divider for 100 Hz operation
	I2C_write(ITG_ADDR, SMPLRT_DIV, 9);	//Fsample = Fint / (divider + 1) where Fint is 1kHz
	
	//Setup the interrupt to trigger when new data is ready.
	I2C_write(ITG_ADDR, INT_CFG, INT_CFG_RAW_RDY_EN | INT_CFG_ITG_RDY_EN);
	
	//Select X gyro PLL for clock source
	I2C_write(ITG_ADDR, PWR_MGM, PWR_MGM_CLK_SEL_0);
}

//Reads the x,y and z registers and stores the contents into x,y and z variables
//returns 1
//usage: gyro.update();
//Note: update must be called before using the getX, getY or getZ functions in order
//      to obtain the most recent values from the gyro
void Gyro_Update(gyro_data_t gyro_data)
{
	char aux0=0,aux1=0;

	I2C_read(ITG_ADDR, GYRO_XOUT_H, &aux1);
	I2C_read(ITG_ADDR, GYRO_XOUT_L, &aux0);
	gyro_data->x = (aux1<<8)|aux0;
	
	I2C_read(ITG_ADDR, GYRO_YOUT_H, &aux1);
	I2C_read(ITG_ADDR, GYRO_YOUT_L, &aux0);
	gyro_data->y = (aux1<<8)|aux0;

	I2C_read(ITG_ADDR, GYRO_ZOUT_H, &aux1);
	I2C_read(ITG_ADDR, GYRO_ZOUT_L, &aux0);
	gyro_data->z = (aux1<<8)|aux0;

	I2C_read(ITG_ADDR, TEMP_OUT_H, &aux1);
	I2C_read(ITG_ADDR, TEMP_OUT_L, &aux0);
	gyro_data->temp = (aux1<<8)|aux0;
}

/*
get functions return the g value of the specified axis
usage: printf("Xg = %1.3fg", (double)gyro.getX()
*/

/* TODO: remover
void Gyro_GetX()
{
	Gyro_Xr = (float)Gyro_X/14.375;
}

void Gyro_GetY()
{
	Gyro_Yr = (float)Gyro_Y/14.375;
}

void Gyro_GetZ()
{
	Gyro_Zr = (float)Gyro_Z/14.375;
}
*/

float Gyro_GetTemp(gyro_data_t gyro_data)
{
	int16_t Gyro_Temp = 13200+gyro_data->temp;    //Get the offset temp
    float Gyro_Tempr = ((float)Gyro_Temp)/280.0;    //Convert the offset to degree C
	return Gyro_Tempr + 35.0;    //Add 35 degrees C to compensate for the offset
} 
\end{verbatim}

\subsubsection{ITG3200.h}

\begin{verbatim}
#ifndef ITG3200_h
#define ITG3200_h

#include <stdint.h>
#include "driver_config.h"
#include "type.h"
#include "i2c_driver.h"

typedef struct gyro_data_t {
	int16_t x, y, z;     // Sinal tridimensional do giroscópio
	int16_t temp;        // Temperatura do giroscópio
}* gyro_data_t;

/* TODO: remover
int Gyro_X;
int Gyro_Y;
int Gyro_Z;
int Gyro_Temp;
float Gyro_Xr;
float Gyro_Yr;
float Gyro_Zr;
float Gyro_Tempr;
*/
void Gyro_Init();
void Gyro_Update(gyro_data_t gyro_data);
/* TODO: remover
void Gyro_GetX();
void Gyro_GetY();
void Gyro_GetZ();
*/
float Gyro_GetTemp(gyro_data_t gyro_data);

/* ************************ Register map for the ITG3200 ****************************/
#define ITG_ADDR	0xD0 //0xD0 if tied low, 0xD2 if tied high

#define WHO_AM_I	0x00
#define SMPLRT_DIV	0x15
#define	DLPF_FS		0x16
#define INT_CFG		0x17
#define INT_STATUS	0x1A
#define	TEMP_OUT_H	0x1B
#define	TEMP_OUT_L	0x1C
#define GYRO_XOUT_H	0x1D
#define	GYRO_XOUT_L	0x1E
#define GYRO_YOUT_H	0x1F
#define GYRO_YOUT_L	0x20
#define GYRO_ZOUT_H	0x21
#define GYRO_ZOUT_L	0x22
#define	PWR_MGM		0x3E

//Sample Rate Divider
//Fsample = Fint / (divider + 1) where Fint is either 1kHz or 8kHz
//Fint is set to 1kHz
//Set divider to 9 for 100 Hz sample rate

//DLPF, Full Scale Register Bits
//FS_SEL must be set to 3 for proper operation
//Set DLPF_CFG to 3 for 1kHz Fint and 42 Hz Low Pass Filter
#define DLPF_CFG_0	(1<<0)
#define DLPF_CFG_1	(1<<1)
#define DLPF_CFG_2	(1<<2)
#define DLPF_FS_SEL_0	(1<<3)
#define DLPF_FS_SEL_1	(1<<4)

//Power Management Register Bits
//Recommended to set CLK_SEL to 1,2 or 3 at startup for more stable clock
#define PWR_MGM_CLK_SEL_0	(1<<0)
#define PWR_MGM_CLK_SEL_1	(1<<1)
#define PWR_MGM_CLK_SEL_2	(1<<2)
#define PWR_MGM_STBY_Z	(1<<3)
#define PWR_MGM_STBY_Y	(1<<4)
#define PWR_MGM_STBY_X	(1<<5)
#define PWR_MGM_SLEEP	(1<<6)
#define PWR_MGM_H_RESET	(1<<7)

//Interrupt Configuration Bist
#define INT_CFG_ACTL	(1<<7)
#define INT_CFG_OPEN	(1<<6)
#define INT_CFG_LATCH_INT_EN	(1<<5)
#define INT_CFG_INT_ANYRD	(1<<4)
#define INT_CFG_ITG_RDY_EN	(1<<2)
#define INT_CFG_RAW_RDY_EN	(1<<0)

#endif 
\end{verbatim}

  \section{Navegação}

Nesta seção serão listados todo o software utilizado para navegação. Ele será dividido entre o programa que contém o loop principal e os arquivos auxiliares que contém parte do programa relativo ao GPS e ao sensor de proximidade.

Todos estes softwares devem ser programados em uma placa arduíno Mega. Para a gravação dos códigos da navegação foi utilizado a versão 1.0 do programa de gravação do arduíno. Para obter mais informações sobre o Arduíno bem como programa-lo consulte o site: www.arduino.cc .

  \subsection{Navegação - Loop principal}

Todo o código do loop principal da navegação foi desenvolvido pelos membros deste projeto. Segue abaixo o código do programa desenvolvido.

\subsubsection{navegacao.ino}
\begin{verbatim}
/*
===============================================================================

 Name        : navegacao.ino
 Author      : Bruno Pinho
 Revision    : Danilo Luvizotto e Pedro Nariyoshi
 Version     : 1.0
 Description : Navigation of Hiperion - Quadcopter

===============================================================================
*/

#include "Ultrasonic.h"
#include "TinyGPS.h"

//Define a pinagem
#define echoPin 52 //Pino 52 recebe o pulso do echo SENSOR DISTANCIA
#define trigPin 50 //Pino 50 envia o pulso para gerar o echo SENSOR DISTANCIA
//Constantes
#define CENTRADO 127 // Os comandos variam de 0 a 255 - 127 e' o centro
#define ANGULOGPS 5 // Valor do angulo usado no GPS
#define YAWPADRAO 30 // Velocidade padrao de rotacao
#define MARGEMGPS 10 // Margem de erro do GPS (0,0001 = 10m aproximadamente no equador)
#define MAXDIST 300 // Distancia maxima do sensor de distancia (em cm)
#define T_AMOSTRAGEM 1000
//Modos de navegacao
#define DESLIGAR 0
#define POUSAR 1
#define MANUAL 2
#define LIVRE 3
#define GPS 4
//Controle de altura
#define altura_throttle_max 100
#define altura_throttle_min 1
#define ALTURA_POUSO 5
#define ki 1

Ultrasonic ultrasonic(50,52); //iniciando a função e passando os pinos SENSOR DISTANCIA
TinyGPS gps;
bool feedgps();

//Variaveis
int altura; //SENSOR DISTANCIA se altura = 0, sensor nao encontrou distancia.
int roll=0, pitch=0, yaw=0, throttle=0; //Dados para a camada de controle
int MODO = DESLIGAR; // Modo de navegacao
long lat, lon, alt; //Latitude, Longitude e altura(cm) (GPS)
unsigned long age, date, time, chars; // date(ddmmyy), time(hhmmsscc) GPS
unsigned short sentences, failed; // Informacoes GPS
long latdestino, londestino, latresultante, lonresultante, modlat, modlon, distgps = 0, distantgps; //Usado para navegacao GPS
bool gps_disponivel;
float angmag=500; // Angulo do magnetometro, valor inicial 500 que significa que o magnetometro nao esta conectado
float rollcontrol=0, pitchcontrol=0, yawcontrol=0, throttlecontrol=0; //Dados do controle , tambem usado como variavel auxiliar no gps
long ultima_execucao; // Tempo de execucao
//Objeto controlador proporcional, integral e derivativo.
int altura_alvo;
int altura_saida;
int altura_erro_acumulado = 0;
//Bluetooth
int Conectado = 0;

void manda_dados(int roll, int pitch, int yaw, int throttle) {
      Serial2.print("R");
      Serial2.print(roll+CENTRADO);
      Serial2.print("P");
      Serial2.print(pitch+CENTRADO);
      Serial2.print("Y");
      Serial2.print(yaw+CENTRADO);
      Serial2.print("T");
      Serial2.print(throttle+CENTRADO);
}

void setup() {
    Serial.begin(115200); // Para debug
    Serial1.begin(57600); // Para GPS
    Serial2.begin(115200); // Para a camada de Controle
    Serial2.begin(115200); // Para bluetooth
    pinMode(echoPin, INPUT); // define o pino 52 como entrada (recebe) SENSOR DISTANCIA
    pinMode(trigPin, OUTPUT); // define o pino 48 como saida (envia) SENSOR DISTANCIA
    pinMode(13, OUTPUT); // O pino 13 é um led, que será usado para indicar erro.
    delay(3000);  // Espera 3 segundos para garantir que os periféricos e componentes externos estão prontos.
    ultima_execucao = millis();
}

bool le_gps() {
    if (feedgps()) {
        gps.get_position(&lat, &lon, &age);
        feedgps();
        gps.get_datetime(&date, &time, &age);
        feedgps();
        gps.stats(&chars, &sentences, &failed);
        alt = gps.altitude();
        return true;
    }
    return false;
}

void sinaliza_erro(char error_code) {
    switch (error_code) {
        case 0: // O loop demorou mais que T_AMOSTRAGEM para ser executado.
            while(1) {
                digitalWrite(13, HIGH);   // liga o led
                delay(100);               // espera
                digitalWrite(13, LOW);    // desliga o led
                delay(400);               // espera
            }
            break;
        default:
            break;
    }
}

int cont_altura() { // Controle de altura
  if(altura == 0) // usando o sensor de distancia
    return altura_erro_acumulado;
    
  int erro = altura_alvo - altura;
  altura_erro_acumulado += (ki * erro);
  if(altura_erro_acumulado > altura_throttle_max)
      altura_erro_acumulado = altura_throttle_max;
  else if(altura_erro_acumulado < altura_throttle_min)
      altura_erro_acumulado = altura_throttle_min;
  return altura_erro_acumulado;
}

void estavel() {   // Mantem o multirrotor estavel
  //Calcula o Roll e pitch caso seja necessario para ajudar na estabilizacao
  roll = 0;
  pitch = 0;
  yaw = 0;
  manda_dados(roll, pitch, yaw, cont_altura());
}

void bluetooth() {   // Tratamento dos dados do bluetooth
  int inByte;
  if(Conectado == 0 && Serial3.available()) {
    inByte = Serial3.read();    
    if (inByte = 'R') {
      inByte = Serial3.read();
      if (inByte = 'F') {
        inByte = Serial3.read();
        if (inByte = 'C') {
          inByte = Serial3.read();
          if (inByte = 'O') {
            inByte = Serial3.read();
            if (inByte = 'M') {
              inByte = Serial3.read();
              if (inByte = 'M') {
                Conectado = 1;
                delay(50);
                Serial3.flush();
              }
            }
          }
        }
      }
    }   
  }

  if(Conectado == 1) {
    for(int i = 1; i <= 8; i++) {
      inByte = Serial3.read();
      switch(inByte) {
        case 'M': //Modo sendo recebido
          inByte = Serial3.read();
          if(inByte == 'N') {
            inByte = Serial3.read();    
            if (inByte = 'O') {
              inByte = Serial3.read();
              if (inByte = ' ') {
                inByte = Serial3.read();
                if (inByte = 'C') {
                  inByte = Serial3.read();
                  if (inByte = 'A') {
                    inByte = Serial3.read();
                    if (inByte = 'R') {
                      Conectado = 0;
                      delay(50);
                      Serial3.flush();
                    }
                  }
                }
              }
            }
          }
          else
            MODO = inByte;          
          break;
        
        case 'R': //Roll sendo recebido
          inByte = Serial3.read();
          roll = (Serial3.read() - '0') * 100;
          roll =+ (Serial3.read() - '0') * 10;
          roll =+ (Serial3.read() - '0') * 1;
          roll =- 127;
          break;

        case 'P': //Pitch sendo recebido
          pitch = (Serial3.read() - '0') * 100;
          pitch =+ (Serial3.read() - '0') * 10;
          pitch =+ (Serial3.read() - '0') * 1;
          pitch =- 127;
          break;

        case 'Y': //Yaw sendo recebido
          yaw = (Serial3.read() - '0') * 100;
          yaw =+ (Serial3.read() - '0') * 10;
          yaw =+ (Serial3.read() - '0') * 1;
          yaw =- 127;
          break;

        case 'T': //Throttle sendo recebido
          throttle = (Serial3.read() - '0') * 100;
          throttle =+ (Serial3.read() - '0') * 10;
          throttle =+ (Serial3.read() - '0') * 1;
          throttle =- 127;
          break;
        
        case 'A': //Altura sendo recebida
          altura_alvo = (Serial3.read() - '0') * 1000;
          altura_alvo =+ (Serial3.read() - '0') * 100;
          altura_alvo =+ (Serial3.read() - '0') * 10;
          break;
        //Ainda estao erradas latitude e longitude.
        case 'K': //latitude sendo recebida
          inByte = Serial3.read();
          latdestino = (Serial3.read() - '0') * 1000000;
          latdestino =+ (Serial3.read() - '0') * 100000;
          latdestino =+ (Serial3.read() - '0') * 10000;
          latdestino =+ (Serial3.read() - '0') * 1000;
          latdestino =+ (Serial3.read() - '0') * 100;
          latdestino =+ (Serial3.read() - '0') * 10;
          latdestino =+ (Serial3.read() - '0') * 1;
          if(inByte == '-')
            latdestino = 0 - latdestino;
          break;

        case 'L': //longitude sendo recebida
          inByte = Serial3.read();
          londestino = (Serial3.read() - '0') * 10000000;
          londestino =+ (Serial3.read() - '0') * 1000000;
          londestino =+ (Serial3.read() - '0') * 100000;
          londestino =+ (Serial3.read() - '0') * 10000;
          londestino =+ (Serial3.read() - '0') * 1000;
          londestino =+ (Serial3.read() - '0') * 100;
          londestino =+ (Serial3.read() - '0') * 10;
          londestino =+ (Serial3.read() - '0') * 1;
          if(inByte == '-')
            londestino = 0 - londestino;
          break;
          
        case 'N': // Caso a conexao tenha sido perdida
          inByte = Serial3.read();    
          if (inByte = 'O') {
            inByte = Serial3.read();
            if (inByte = ' ') {
              inByte = Serial3.read();
              if (inByte = 'C') {
                inByte = Serial3.read();
                if (inByte = 'A') {
                  inByte = Serial3.read();
                  if (inByte = 'R') {
                    Conectado = 0;
                    delay(50);
                    Serial3.flush();
                  }
                }
              }
            }
          }   
          break;
          
        case 'O': // Caso a conexao tenha sido perdida
          inByte = Serial3.read();
          if (inByte = ' ') {
            inByte = Serial3.read();
            if (inByte = 'C') {
              inByte = Serial3.read();
              if (inByte = 'A') {
                inByte = Serial3.read();
                if (inByte = 'R') {
                  Conectado = 0;
                  delay(50);
                  Serial3.flush();
                }
              }
            }
          }
          break;

        default:
          break;
      }
    }
    Serial3.flush();
  }
}

void loop() {
  if(millis() - ultima_execucao > T_AMOSTRAGEM )
      //sinaliza_erro(0);    // O último loop demorou mais que T_AMOSTRAGEM para ser executado.
      Serial.println("ERRO!");
      
   //Espera o tempo de amostragem
  while(millis() - ultima_execucao < T_AMOSTRAGEM);
  
  //TODO: Tratar dados do Controle remoto
  bluetooth(); // Pegar dados pelo bluetooth
  if(Conectado == 0) //Caso o controle bluetooth esteja desconectado ele entra no modo POUSAR
    MODO = POUSAR;
  altura = ultrasonic.Distancia(trigPin);   //Calcula a altura em centimetros atraves do sensor de distância
  gps_disponivel = le_gps();               //Lê os dados do GPS
  angmag = 500;           // Lê os dados do magnetometro (500 significa sem magnetômetro)
  if(MODO > GPS) // Caso tenha entrado em algum modo inexistente - GPS  o ultimo modo
    MODO = POUSAR;

  switch(MODO) {
      case DESLIGAR:                //Fazer o multirrotor pousar em segurança
          manda_dados(0, 0, 0, 0);   //Desliga os motores
          break;
                  
      case POUSAR:                //Fazer o multirrotor pousar em segurança
          if(altura < ALTURA_POUSO)
              manda_dados(0, 0, 0, 0);   //Desliga os motores
          else {                  //Diminui o throtle gradativamente até o throttle mínimo permitido
              altura_alvo = 0;
              manda_dados(0, 0, 0, cont_altura());
          }
          break;

      case MANUAL:                //O multirrotor está no modo de navegação manual
           manda_dados(roll, pitch, yaw, cont_altura());
           break;
            
      case LIVRE:                 //O multirrotor está no modo de navegação livre
          manda_dados(roll, pitch, yaw, throttle);
          break;
            
      case GPS:                   //O multirrotor está navegando pelo GPS
          if (gps_disponivel) { //GPS esta com sinal
            if(angmag == 500) { // Magnetometro desconectado ou inexistente
              roll = ANGULOGPS;
              latresultante = latdestino-lat;
              lonresultante = londestino-lon;
              distgps = latresultante*latresultante + lonresultante*lonresultante;
              if(distgps <= MARGEMGPS*MARGEMGPS) 
                estavel();
              else {
                if(distgps <= distantgps || distantgps == 0) //Se distancia estiver diminuindo ou quando iniciado(distantgps=0) ele segue em frente
                  yaw = 0;
                else //Caso contrario ele vira a direita.
                  yaw = YAWPADRAO;
              }
              manda_dados(roll, 0, yaw, cont_altura());
              distantgps = distgps; // distantgps guarda a distancia gps para usar na proxima iteracao
            }
            //Fazer a rotacao ate sincronizar com o norte utilizando o magnetometro
            else if(angmag > 3 && angmag <=180)  // Colocar uma margem de erro de 3 graus - Sentido horario
                manda_dados(0, 0, YAWPADRAO, cont_altura());

            else if(angmag > 180 && angmag < 357)  // Sentido anti-horario com uma margem de 3 graus
                manda_dados(0, 0, -YAWPADRAO, cont_altura());
            
            else { //Compara destino GPS
                latresultante = latdestino-lat;
                lonresultante = londestino-lon;
                modlat = abs(latresultante);
                modlon = abs(lonresultante);
                if(modlat <= MARGEMGPS && modlon <= MARGEMGPS) // Chegou na localizacao, mantem ele estavel
                    estavel();    

                else if(modlat <= MARGEMGPS) { // Latitude alcancada
                    if(latresultante < 0) { // Esquerda
                        roll = ANGULOGPS;
                        manda_dados(roll, 0, 0, cont_altura());
                    }
                    else { // Direita
                        roll = - ANGULOGPS;
                        manda_dados(roll, 0, 0, cont_altura());
                    }            
                }

                else if(modlon <= MARGEMGPS) { // Longitude alcancada
                    if(lonresultante < 0) { // 
                        pitch = ANGULOGPS;
                        manda_dados(0, pitch, 0, cont_altura());
                    }
                    else { // Frente
                        pitch = - ANGULOGPS;
                        manda_dados(0, pitch, 0, cont_altura());                            
                    }            
                }

                else if(modlat > modlon) { // Caso ele tenha que andar mais latitude que longitude
                    if(latresultante > 0)
                        roll = ANGULOGPS;
                    else 
                        roll = -ANGULOGPS;
                    if(lonresultante > 0)
                        pitch = ANGULOGPS * (modlon / modlat);
                    else
                        pitch = - ANGULOGPS * (modlon / modlat);
                    manda_dados(roll, pitch, 0, cont_altura());
                }
                    
                else if(modlon >= modlat) { // Caso ele tenha que andar mais lontitude que latitude
                    if(lonresultante > 0)
                        pitch = ANGULOGPS;
                    else
                        pitch = -ANGULOGPS;
                    if(latresultante > 0)
                        roll = ANGULOGPS * (modlat / modlon);
                    else
                        roll = - ANGULOGPS * (modlat / modlon);
                    manda_dados(roll, pitch, 0, cont_altura());
                }
            }
      }
      else //Sem sinal do GPS, mantem ele estavel
          estavel();
      break;
  }
  ultima_execucao = millis();
}

bool feedgps() {
  while (Serial1.available()) {
    if (gps.encode(Serial1.read()))
      return true;
  }
  return false;
}\end{verbatim}


  \subsection{GPS}

Foi usada uma biblioteca para facilitar a obtenção dos dados do GPS pelo arduíno.

Seguem abaixo os arquivo utilizados:

\subsubsection{TinyGPS.cpp}

\begin{verbatim}
/*
  TinyGPS - a small GPS library for Arduino providing basic NMEA parsing
  Based on work by and "distance_to" courtesy of Maarten Lamers.
  Copyright (C) 2008-2011 Mikal Hart
  All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "TinyGPS.h"

#define _GPRMC_TERM   "GPRMC"
#define _GPGGA_TERM   "GPGGA"

TinyGPS::TinyGPS()
:  _time(GPS_INVALID_TIME)
,  _date(GPS_INVALID_DATE)
,  _latitude(GPS_INVALID_ANGLE)
,  _longitude(GPS_INVALID_ANGLE)
,  _altitude(GPS_INVALID_ALTITUDE)
,  _speed(GPS_INVALID_SPEED)
,  _course(GPS_INVALID_ANGLE)
,  _last_time_fix(GPS_INVALID_FIX_TIME)
,  _last_position_fix(GPS_INVALID_FIX_TIME)
,  _parity(0)
,  _is_checksum_term(false)
,  _sentence_type(_GPS_SENTENCE_OTHER)
,  _term_number(0)
,  _term_offset(0)
,  _gps_data_good(false)
#ifndef _GPS_NO_STATS
,  _encoded_characters(0)
,  _good_sentences(0)
,  _failed_checksum(0)
#endif
{
  _term[0] = '\0';
}

//
// public methods
//

bool TinyGPS::encode(char c)
{
  bool valid_sentence = false;

  ++_encoded_characters;
  switch(c)
  {
  case ',': // term terminators
    _parity ^= c;
  case '\r':
  case '\n':
  case '*':
    if (_term_offset < sizeof(_term))
    {
      _term[_term_offset] = 0;
      valid_sentence = term_complete();
    }
    ++_term_number;
    _term_offset = 0;
    _is_checksum_term = c == '*';
    return valid_sentence;

  case '$': // sentence begin
    _term_number = _term_offset = 0;
    _parity = 0;
    _sentence_type = _GPS_SENTENCE_OTHER;
    _is_checksum_term = false;
    _gps_data_good = false;
    return valid_sentence;
  }

  // ordinary characters
  if (_term_offset < sizeof(_term) - 1)
    _term[_term_offset++] = c;
  if (!_is_checksum_term)
    _parity ^= c;

  return valid_sentence;
}

#ifndef _GPS_NO_STATS
void TinyGPS::stats(unsigned long *chars, unsigned short *sentences, unsigned short *failed_cs)
{
  if (chars) *chars = _encoded_characters;
  if (sentences) *sentences = _good_sentences;
  if (failed_cs) *failed_cs = _failed_checksum;
}
#endif

//
// internal utilities
//
int TinyGPS::from_hex(char a) 
{
  if (a >= 'A' && a <= 'F')
    return a - 'A' + 10;
  else if (a >= 'a' && a <= 'f')
    return a - 'a' + 10;
  else
    return a - '0';
}

unsigned long TinyGPS::parse_decimal()
{
  char *p = _term;
  bool isneg = *p == '-';
  if (isneg) ++p;
  unsigned long ret = 100UL * gpsatol(p);
  while (gpsisdigit(*p)) ++p;
  if (*p == '.')
  {
    if (gpsisdigit(p[1]))
    {
      ret += 10 * (p[1] - '0');
      if (gpsisdigit(p[2]))
        ret += p[2] - '0';
    }
  }
  return isneg ? -ret : ret;
}

unsigned long TinyGPS::parse_degrees()
{
  char *p;
  unsigned long left = gpsatol(_term);
  unsigned long tenk_minutes = (left % 100UL) * 10000UL;
  for (p=_term; gpsisdigit(*p); ++p);
  if (*p == '.')
  {
    unsigned long mult = 1000;
    while (gpsisdigit(*++p))
    {
      tenk_minutes += mult * (*p - '0');
      mult /= 10;
    }
  }
  return (left / 100) * 100000 + tenk_minutes / 6;
}

// Processes a just-completed term
// Returns true if new sentence has just passed checksum test and is validated
bool TinyGPS::term_complete()
{
  if (_is_checksum_term)
  {
    byte checksum = 16 * from_hex(_term[0]) + from_hex(_term[1]);
    if (checksum == _parity)
    {
      if (_gps_data_good)
      {
#ifndef _GPS_NO_STATS
        ++_good_sentences;
#endif
        _last_time_fix = _new_time_fix;
        _last_position_fix = _new_position_fix;

        switch(_sentence_type)
        {
        case _GPS_SENTENCE_GPRMC:
          _time      = _new_time;
          _date      = _new_date;
          _latitude  = _new_latitude;
          _longitude = _new_longitude;
          _speed     = _new_speed;
          _course    = _new_course;
          break;
        case _GPS_SENTENCE_GPGGA:
          _altitude  = _new_altitude;
          _time      = _new_time;
          _latitude  = _new_latitude;
          _longitude = _new_longitude;
          break;
        }

        return true;
      }
    }

#ifndef _GPS_NO_STATS
    else
      ++_failed_checksum;
#endif
    return false;
  }

  // the first term determines the sentence type
  if (_term_number == 0)
  {
    if (!gpsstrcmp(_term, _GPRMC_TERM))
      _sentence_type = _GPS_SENTENCE_GPRMC;
    else if (!gpsstrcmp(_term, _GPGGA_TERM))
      _sentence_type = _GPS_SENTENCE_GPGGA;
    else
      _sentence_type = _GPS_SENTENCE_OTHER;
    return false;
  }

  if (_sentence_type != _GPS_SENTENCE_OTHER && _term[0])
  switch((_sentence_type == _GPS_SENTENCE_GPGGA ? 200 : 100) + _term_number)
  {
    case 101: // Time in both sentences
    case 201:
      _new_time = parse_decimal();
      _new_time_fix = millis();
      break;
    case 102: // GPRMC validity
      _gps_data_good = _term[0] == 'A';
      break;
    case 103: // Latitude
    case 202:
      _new_latitude = parse_degrees();
      _new_position_fix = millis();
      break;
    case 104: // N/S
    case 203:
      if (_term[0] == 'S')
        _new_latitude = -_new_latitude;
      break;
    case 105: // Longitude
    case 204:
      _new_longitude = parse_degrees();
      break;
    case 106: // E/W
    case 205:
      if (_term[0] == 'W')
        _new_longitude = -_new_longitude;
      break;
    case 107: // Speed (GPRMC)
      _new_speed = parse_decimal();
      break;
    case 108: // Course (GPRMC)
      _new_course = parse_decimal();
      break;
    case 109: // Date (GPRMC)
      _new_date = gpsatol(_term);
      break;
    case 206: // Fix data (GPGGA)
      _gps_data_good = _term[0] > '0';
      break;
    case 209: // Altitude (GPGGA)
      _new_altitude = parse_decimal();
      break;
  }

  return false;
}

long TinyGPS::gpsatol(const char *str)
{
  long ret = 0;
  while (gpsisdigit(*str))
    ret = 10 * ret + *str++ - '0';
  return ret;
}

int TinyGPS::gpsstrcmp(const char *str1, const char *str2)
{
  while (*str1 && *str1 == *str2)
    ++str1, ++str2;
  return *str1;
}

/* static */
float TinyGPS::distance_between (float lat1, float long1, float lat2, float long2) 
{
  // returns distance in meters between two positions, both specified 
  // as signed decimal-degrees latitude and longitude. Uses great-circle 
  // distance computation for hypothetical sphere of radius 6372795 meters.
  // Because Earth is no exact sphere, rounding errors may be up to 0.5%.
  // Courtesy of Maarten Lamers
  float delta = radians(long1-long2);
  float sdlong = sin(delta);
  float cdlong = cos(delta);
  lat1 = radians(lat1);
  lat2 = radians(lat2);
  float slat1 = sin(lat1);
  float clat1 = cos(lat1);
  float slat2 = sin(lat2);
  float clat2 = cos(lat2);
  delta = (clat1 * slat2) - (slat1 * clat2 * cdlong); 
  delta = sq(delta); 
  delta += sq(clat2 * sdlong); 
  delta = sqrt(delta); 
  float denom = (slat1 * slat2) + (clat1 * clat2 * cdlong); 
  delta = atan2(delta, denom); 
  return delta * 6372795; 
} 
\end{verbatim}

\subsubsection{TinyGPS.h}

\begin{verbatim}
/*
  TinyGPS - a small GPS library for Arduino providing basic NMEA parsing
  Based on work by and "distance_to" courtesy of Maarten Lamers.
  Copyright (C) 2008-2011 Mikal Hart
  All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#ifndef TinyGPS_h
#define TinyGPS_h

#include "Arduino.h"

#define _GPS_VERSION 10 // software version of this library
#define _GPS_MPH_PER_KNOT 1.15077945
#define _GPS_MPS_PER_KNOT 0.51444444
#define _GPS_KMPH_PER_KNOT 1.852
#define _GPS_MILES_PER_METER 0.00062137112
#define _GPS_KM_PER_METER 0.001
//#define _GPS_NO_STATS

class TinyGPS
{
  public:
    TinyGPS();
    bool encode(char c); // process one character received from GPS
    TinyGPS &operator << (char c) {encode(c); return *this;}    
    // lat/long in hundred thousandths of a degree and age of fix in milliseconds
    inline void get_position(long *latitude, long *longitude, unsigned long *fix_age = 0)
    {
      if (latitude) *latitude = _latitude;
      if (longitude) *longitude = _longitude;
      if (fix_age) *fix_age = _last_position_fix == GPS_INVALID_FIX_TIME ? 
        GPS_INVALID_AGE : millis() - _last_position_fix;
    }
    // date as ddmmyy, time as hhmmsscc, and age in milliseconds
    inline void get_datetime(unsigned long *date, unsigned long *time, unsigned long *fix_age = 0)
    {
      if (date) *date = _date;
      if (time) *time = _time;
      if (fix_age) *fix_age = _last_time_fix == GPS_INVALID_FIX_TIME ? 
        GPS_INVALID_AGE : millis() - _last_time_fix;
    }

    // signed altitude in centimeters (from GPGGA sentence)
    inline long altitude() { return _altitude; }

    // course in last full GPRMC sentence in 100th of a degree
    inline unsigned long course() { return _course; }
    
    // speed in last full GPRMC sentence in 100ths of a knot
    unsigned long speed() { return _speed; }

#ifndef _GPS_NO_STATS
    void stats(unsigned long *chars, unsigned short *good_sentences, unsigned short *failed_cs);
#endif
    inline void f_get_position(float *latitude, float *longitude, unsigned long *fix_age = 0)
    {
      long lat, lon;
      get_position(&lat, &lon, fix_age);
      *latitude = lat / 100000.0;
      *longitude = lon / 100000.0;
    }

    inline void crack_datetime(int *year, byte *month, byte *day, 
      byte *hour, byte *minute, byte *second, byte *hundredths = 0, unsigned long *fix_age = 0)
    {
      unsigned long date, time;
      get_datetime(&date, &time, fix_age);
      if (year) 
      {
        *year = date % 100;
        *year += *year > 80 ? 1900 : 2000;
      }
      if (month) *month = (date / 100) % 100;
      if (day) *day = date / 10000;
      if (hour) *hour = time / 1000000;
      if (minute) *minute = (time / 10000) % 100;
      if (second) *second = (time / 100) % 100;
      if (hundredths) *hundredths = time % 100;
    }

    inline float f_altitude()    { return altitude() / 100.0; }
    inline float f_course()      { return course() / 100.0; }
    inline float f_speed_knots() { return speed() / 100.0; }
    inline float f_speed_mph()   { return _GPS_MPH_PER_KNOT * f_speed_knots(); }
    inline float f_speed_mps()   { return _GPS_MPS_PER_KNOT * f_speed_knots(); }
    inline float f_speed_kmph()  { return _GPS_KMPH_PER_KNOT * f_speed_knots(); }

    static int library_version() { return _GPS_VERSION; }

    enum {GPS_INVALID_AGE = 0xFFFFFFFF, GPS_INVALID_ANGLE = 999999999, GPS_INVALID_ALTITUDE = 999999999, GPS_INVALID_DATE = 0,
      GPS_INVALID_TIME = 0xFFFFFFFF, GPS_INVALID_SPEED = 999999999, GPS_INVALID_FIX_TIME = 0xFFFFFFFF};


    static float distance_between (float lat1, float long1, float lat2, float long2);
private:
    enum {_GPS_SENTENCE_GPGGA, _GPS_SENTENCE_GPRMC, _GPS_SENTENCE_OTHER};
    
    // properties
    unsigned long _time, _new_time;
    unsigned long _date, _new_date;
    long _latitude, _new_latitude;
    long _longitude, _new_longitude;
    long _altitude, _new_altitude;
    unsigned long  _speed, _new_speed;
    unsigned long  _course, _new_course;

    unsigned long _last_time_fix, _new_time_fix;
    unsigned long _last_position_fix, _new_position_fix;

    // parsing state variables
    byte _parity;
    bool _is_checksum_term;
    char _term[15];
    byte _sentence_type;
    byte _term_number;
    byte _term_offset;
    bool _gps_data_good;

#ifndef _GPS_NO_STATS
    // statistics
    unsigned long _encoded_characters;
    unsigned short _good_sentences;
    unsigned short _failed_checksum;
    unsigned short _passed_checksum;
#endif

    // internal utilities
    int from_hex(char a);
    unsigned long parse_decimal();
    unsigned long parse_degrees();
    bool term_complete();
    bool gpsisdigit(char c) { return c >= '0' && c <= '9'; }
    long gpsatol(const char *str);
    int gpsstrcmp(const char *str1, const char *str2);
};

// Arduino 0012 workaround
#undef int
#undef char
#undef long
#undef byte
#undef float
#undef abs
#undef round 

#endif
 
\end{verbatim}


  \subsection{Sensor de proximidade}
Os arquivos utilizados para auxiliar no controle do sensor de distância foi uma biblioteca encontrada na internet que foi devidamente adaptada para a utilização dela no projeto.

Seguem abaixo os arquivos utilizados:

\subsubsection{Ultrasonic.cpp}

\begin{verbatim}
 /*
  Ultrasonic.h - Library for HR-SC04 Ultrasonic Ranging Module.
  Created by ITead studio. Alex, Apr 20, 2010.
  iteadstudio.com
  Adapted for Hiperion - Dez, 2011.
*/


#include "Ultrasonic.h"
#define TMAX 35000 // em micro segundos

Ultrasonic::Ultrasonic(int TP, int EP)
{
   pinMode(TP,OUTPUT);
   pinMode(EP,INPUT);
   Trig_pin=TP;
   Echo_pin=EP;
}

long Ultrasonic::Timing()
{
  digitalWrite(Trig_pin, LOW);
  delayMicroseconds(2);
  digitalWrite(Trig_pin, HIGH);
  delayMicroseconds(10);
  digitalWrite(Trig_pin, LOW);
  duration = pulseIn(Echo_pin,HIGH, TMAX);
  return duration;
}

long Ultrasonic::Ranging(int sys)
{
  Timing();
  distacne_cm = duration /29 / 2 ;
  distance_inc = duration / 74 / 2;
  if (sys)
  return distacne_cm;
  else
  return distance_inc;
}

long Ultrasonic::Distancia(int trigger)
{
  //seta o pino trigger com um pulso baixo "LOW" (ou desligado ou ainda 0)
  digitalWrite(trigger, LOW);
  // delay de 2 microssegundos
  delayMicroseconds(2);
  //seta o pino trigger com pulso alto "HIGH" (ou ligado ou ainda 1)
  digitalWrite(trigger, HIGH);
  //delay de 10 microssegundos
  delayMicroseconds(10);
  //seta o pino trigger com pulso baixo novamente
  digitalWrite(trigger, LOW);
  // função Ranging, faz a conversão do tempo de SENSOR DISTANCIA resposta do echo em centimetros
  return (Ranging(CM));
}
\end{verbatim}

\subsubsection{Ultrasonic.h}

\begin{verbatim}
/*
  Ultrasonic.h - Library for HR-SC04 Ultrasonic Ranging Module.
  Created by ITead studio. Alex, Apr 20, 2010.
  iteadstudio.com
  Adapted for Hiperion - Dez, 2011.
*/


#ifndef Ultrasonic_h
#define Ultrasonic_h

#include "Arduino.h"

#define CM 1
#define INC 0

class Ultrasonic
{
  public:
    Ultrasonic(int TP, int EP);
    long Timing();
    long Ranging(int sys);
    long Distancia(int trigger);

    private:
    int Trig_pin;
    int Echo_pin;
    long  duration,distacne_cm,distance_inc;
    
};

#endif
\end{verbatim}

  \section{QuadArchon - Controle bluetooth}

Para a função do controle remoto, foi utilizado o QuadArchon, que é um aplicativo gratuito desenvolvido para plataforma android que através de bluetooth se comunica mandando os sinais de controle e também recebendo telemetria.

Este aplicativo foi desenvolvido em uma disciplina do departamento de Sistemas Eletrônicos da Escola Politécnica. Toda informação a respeito do QuadArchon, inclusive o aplicativo para download, pode ser encontrada no site: https://sites.google.com/site/quadarchon/ 

 \chapter{Instruções de montagem}
 TODO

 \chapter{ESC - Controlador eletrônico de velocidade}


  \section{Software}



  \section{Hardware}



 \chapter{Considerações Finais}
 TODO

\end{document}
